
<!DOCTYPE html>
<html>
  <head>
    <title>JOS Lab Report</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style> 
    .markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview .pagebreak,.markdown-preview .newpage{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center !important}.markdown-preview:not([for="preview"]) .code-chunk .btn-group{display:none}.markdown-preview:not([for="preview"]) .code-chunk .status{display:none}.markdown-preview:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0}@media screen and (min-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px)}}@media screen and (max-width:914px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode]) .markdown-preview{font-size:14px !important;padding:1em}}@media print{html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for="html-export"]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,0.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,0.66);border:4px solid rgba(150,150,150,0.66);background-clip:content-box}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{padding:0 1.6em;margin-top:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc li{margin-bottom:.8em}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc ul{list-style-type:none}html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% -  300px);padding:2em calc(50% - 457px -  150px);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for="html-export"]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for="html-export"]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}/**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}} 
    /* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */
 
    </style>
    
  </head>
  <body for="html-export">
    <div class="mume markdown-preview">
    <div><div class="code-chunk" data-id="global" data-cmd="python"><div class="input-div"><div class="btn-group"><div class="run-btn btn"><span>▶︎</span></div><div class="run-all-btn btn">all</div></div><div class="status">running...</div></div><div class="output-div"></div></div><div class="code-chunk" data-id="code-chunk-id-1" data-cmd="python"><div class="input-div"><div class="btn-group"><div class="run-btn btn"><span>▶︎</span></div><div class="run-all-btn btn">all</div></div><div class="status">running...</div></div><div class="output-div"><p><span style="display:inline-block;width:50%;text-align:left">Created: Mar 24 2018 10:34:00</span><span style="display:inline-block;width:50%;text-align:right">Last Updated: Mar 24 2018 23:17:28</span></p>
<h1 style="font-style:italic; font-family:Times; font-size:4em" ebook-toc-level-1="" heading="&lt;center&gt;Lab 2 Report&lt;/center&gt;"><center>Lab 2 Report</center></h1>
<div style="font-style:italic; font-family:Times; font-size:1.2em"><center>Shuyang Cao</center><center>Mar 24 2018</center></div>
</div></div><div class="code-chunk" data-id="code-chunk-id-2" data-cmd="toc"><div class="input-div"><div class="btn-group"><div class="run-btn btn"><span>▶︎</span></div><div class="run-all-btn btn">all</div></div><div class="status">running...</div></div><div class="output-div"></div></div><ul>
<li><a href="#physical-page-managements">Physical Page Managements</a>
<ul>
<li><a href="#exercise-1">Exercise 1</a></li>
</ul>
</li>
<li><a href="#virtual-memory">Virtual Memory</a>
<ul>
<li><a href="#exercise-3">Exercise 3</a></li>
<li><a href="#question-1">Question 1</a></li>
<li><a href="#exercise-4">Exercise 4</a></li>
</ul>
</li>
<li><a href="#kernel-address-space">Kernel Address Space</a>
<ul>
<li><a href="#exercise-5">Exercise 5</a></li>
<li><a href="#question-2">Question 2</a></li>
<li><a href="#question-3">Question 3</a></li>
<li><a href="#question-4">Question 4</a></li>
<li><a href="#question-5">Question 5</a></li>
<li><a href="#question-6">Question 6</a></li>
</ul>
</li>
<li><a href="#challenges">Challenges</a>
<ul>
<li><a href="#challenge-1">Challenge 1</a></li>
<li><a href="#challenge-2">Challenge 2</a></li>
<li><a href="#challenge-3">Challenge 3</a></li>
<li><a href="#challenge-4">Challenge 4</a></li>
</ul>
</li>
<li><a href="#grade">Grade</a></li>
</ul>
<h2 class="mume-header" id="physical-page-managements" ebook-toc-level-2="" heading="Physical Page Managements">Physical Page Managements</h2>

<p>JOS maps the last 256MB of 4GB linear address space to its physcial address using a simple formula <code>(uintptr_t)la - KERNBASE</code>. In <code>mem_init()</code>, JOS allocates a <code>npages</code> long array to store some information about each page. Macros <code>PADDR(kva)</code> and <code>KADDR(pa)</code> as well as functions <code>page2pa(struct PageInfo *)</code>, <code>pa2page(physaddr_t)</code> and <code>page2kva(struct PageInfo *)</code> are used to transform addresses among physical address, linear address and pointer to PageInfo.</p>
<p>Through <code>PageInfo.pp_link</code>, JOS establishes a linked list to trace free pages in the PageInfo array, as shown below.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<p>In <code>page_init()</code>, JOS alos initializes the PageInfo array, rules out those pages whose corresponding physical memory are used from JOS’s free page list. The physical memory after <code>page_init()</code> is done is shown below.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<h3 class="mume-header" id="exercise-1" ebook-toc-level-3="" heading="Exercise 1">Exercise 1</h3>

<blockquote>
<p>Q : In the file kern/pmap.c, you must implement code for the following functions (probably in the order given).<br>
<code>boot_alloc()</code><br>
<code>mem_init()</code> (only up to the call to check_page_free_list(1))<br>
<code>page_init()</code><br>
<code>page_alloc()</code><br>
page_free()<br>
<code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether check_page_alloc() reports success. Fix your code so that it passes. You may find it helpful to add your own assert()s to verify that your assumptions are correct.</p>
</blockquote>
<p>The code modified are show in the following <code>git diff</code> log. Since <code>mem_init()</code> is not done after <strong>Exercise 1</strong>, the result is not shown here.</p>
<pre data-role="codeBlock" data-info="git" class="language-git">diff --git a/kern/pmap.c b/kern/pmap.c
index 727ea68..88356e4 100644
<span class="token deleted">--- a/kern/pmap.c</span>
<span class="token inserted">+++ b/kern/pmap.c</span>
<span class="token coord">@@ -5,6 +5,7 @@</span>
 #include &lt;inc/error.h>
 #include &lt;inc/string.h>
 #include &lt;inc/assert.h>
<span class="token inserted">+#include &lt;inc/memlayout.h></span>
 
 #include &lt;kern/pmap.h>
 #include &lt;kern/kclock.h>
@@ -102,8 +103,15 @@ boot_alloc(uint32_t n)
 	// to a multiple of PGSIZE.
 	//
 	// LAB 2: Your code here.
<span class="token inserted">+	result = nextfree;</span>
<span class="token inserted">+	nextfree = ROUNDUP(nextfree + n, PGSIZE);</span>
<span class="token inserted">+	if ((uint32_t)nextfree - KERNBASE > npages*PGSIZE) {</span>
<span class="token inserted">+		panic("Out of Memory!\n");</span>
<span class="token inserted">+		nextfree = result;</span>
<span class="token inserted">+		result = NULL;</span>
<span class="token inserted">+	}</span>
 
<span class="token deleted">-	return NULL;</span>
<span class="token inserted">+	return result;</span>
 }
 
 // Set up a two-level page table:
@@ -148,6 +156,8 @@ mem_init(void)
 	// array.  <span class="token string">'npages'</span> is the number of physical pages in memory.  Use memset
 	// to initialize all fields of each struct PageInfo to 0.
 	// Your code goes here:
<span class="token inserted">+	pages = (struct PageInfo *) boot_alloc(sizeof(struct PageInfo) * npages);</span>
<span class="token inserted">+	memset(pages, 0, sizeof(struct PageInfo)*npages);</span>
 
 
 	//////////////////////////////////////////////////////////////////////
@@ -251,8 +261,110 @@ page_init(void)
 	// Change the code to reflect this.
 	// NB: DO NOT actually touch the physical memory corresponding to
 	// free pages!
<span class="token inserted">+</span>
<span class="token inserted">+	// Keep in mind memset(pages, 0, sizeof(struct PageInfo)*npages); is </span>
<span class="token inserted">+	// called before this function, so we can simply assume whichever</span>
<span class="token inserted">+	// field not set is zero.</span>
<span class="token inserted">+</span>
<span class="token inserted">+	/*</span>
<span class="token inserted">+	 * When page_init() is called, the usage of our physical memory is</span>
<span class="token inserted">+	 * shown in Fig.1. After our page table is initialized, our free</span>
<span class="token inserted">+	 * pages are stringed by a linked list, which looks like a stack,</span>
<span class="token inserted">+	 * as shown in Fig.2.</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 * Figure 1:</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 *       256MB -------------> +--------------------+</span>
<span class="token inserted">+	 *                            |                    |</span>
<span class="token inserted">+	 *                            |                    |</span>
<span class="token inserted">+	 *                            /\/\/\/\/\/\/\/\/\/\/\</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 *       boot_alloc(0) -----> /\/\/\/\/\/\/\/\/\/\/\</span>
<span class="token inserted">+	 *                            |                    |</span>
<span class="token inserted">+	 *                            |  used by kernel    |</span>
<span class="token inserted">+	 *                            |                    |</span>
<span class="token inserted">+	 *       0x00100000(1MB) ---> +--------------------+</span>
<span class="token inserted">+	 *                            |     BIOS ROM       |</span>
<span class="token inserted">+	 *       0x000F0000(960KB) -> +--------------------+</span>
<span class="token inserted">+	 *                            |   16-bit devices,  |</span>
<span class="token inserted">+	 *                            |   expansions ROMs  |</span>
<span class="token inserted">+	 *       0x000C0000(768KB) -> +--------------------+</span>
<span class="token inserted">+	 *                            |    VGA Display     |</span>
<span class="token inserted">+	 *       0x000A0000(640KB) -> +--------------------+</span>
<span class="token inserted">+	 *                            |                    |</span>
<span class="token inserted">+	 *                            |     Low Memory     |</span>
<span class="token inserted">+	 *                            |                    |</span>
<span class="token inserted">+	 *       0x00001000(4KB) ---> |  ~~~~~~~~~~~~~~~~~ |</span>
<span class="token inserted">+	 *                            |   page 0 is used   |</span>
<span class="token inserted">+	 *                            |      by BIOS       |</span>
<span class="token inserted">+	 *       0x00000000 --------> +--------------------+</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 * Figure 2:</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 *       page N    +--------------------+</span>
<span class="token inserted">+	 *                 |      pp_link       | -----\</span>
<span class="token inserted">+	 *                 +--------------------+      |</span>
<span class="token inserted">+	 *                 |      pp_ref        |      |</span>
<span class="token inserted">+	 *                 +--------------------+      |</span>
<span class="token inserted">+	 *                                             |</span>
<span class="token inserted">+	 *                           /-----------------/</span>
<span class="token inserted">+	 *                           |</span>
<span class="token inserted">+	 *                           v</span>
<span class="token inserted">+	 *       page N-1  +--------------------+</span>
<span class="token inserted">+	 *                 |      pp_link       | -----\</span>
<span class="token inserted">+	 *                 +--------------------+      |</span>
<span class="token inserted">+	 *                 |      pp_ref        |      |</span>
<span class="token inserted">+	 *                 +--------------------+      |</span>
<span class="token inserted">+	 *                                             |</span>
<span class="token inserted">+	 *                           .</span>
<span class="token inserted">+	 *                           .</span>
<span class="token inserted">+	 *                           .</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 *                           /-----------------/</span>
<span class="token inserted">+	 *                           |</span>
<span class="token inserted">+	 *                           v</span>
<span class="token inserted">+	 *       page 1    +--------------------+</span>
<span class="token inserted">+	 *                 |      pp_link       | -----\</span>
<span class="token inserted">+	 *                 +--------------------+      |</span>
<span class="token inserted">+	 *                 |      pp_ref        |      |</span>
<span class="token inserted">+	 *                 +--------------------+      |</span>
<span class="token inserted">+	 *                                             |</span>
<span class="token inserted">+	 *                           /-----------------/</span>
<span class="token inserted">+	 *                           |</span>
<span class="token inserted">+	 *                           v</span>
<span class="token inserted">+	 *       page 0    +--------------------+</span>
<span class="token inserted">+	 *                 |    pp_link=NULL    |</span>
<span class="token inserted">+	 *                 +--------------------+</span>
<span class="token inserted">+	 *                 |      pp_ref        |</span>
<span class="token inserted">+	 *                 +--------------------+</span>
<span class="token inserted">+	 * </span>
<span class="token inserted">+	 */</span>
<span class="token inserted">+</span>
<span class="token inserted">+	page_free_list = NULL;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	pages[0].pp_ref = 1;		// mark physical page 0 as in use</span>
 	size_t i;
<span class="token deleted">-	for (i = 0; i &lt; npages; i++) {</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	for (i = 1; i &lt; npages_basemem; ++i) {</span>
<span class="token inserted">+		// The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span>
<span class="token inserted">+		// is free.</span>
<span class="token inserted">+		pages[i].pp_ref = 0;</span>
<span class="token inserted">+		pages[i].pp_link = page_free_list;</span>
<span class="token inserted">+		page_free_list = &amp;pages[i];</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	size_t kernel_end_page = ((uint32_t)(boot_alloc(0)) - KERNBASE)/PGSIZE;</span>
<span class="token inserted">+	for (; i &lt; kernel_end_page; ++i) {</span>
<span class="token inserted">+		// IO hole and kernel physical memory reside consecutively</span>
<span class="token inserted">+		// in physcial memory. So initialize their corresponding </span>
<span class="token inserted">+		// page entries in one loop</span>
<span class="token inserted">+		pages[i].pp_ref = 1;</span>
<span class="token inserted">+		pages[i].pp_link = NULL;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	for (; i &lt; npages; ++i) {</span>
<span class="token inserted">+		// The rest of extended memory are not used</span>
 		pages[i].pp_ref = 0;
 		pages[i].pp_link = page_free_list;
 		page_free_list = &amp;pages[i];
@@ -274,8 +386,17 @@ page_init(void)
 struct PageInfo *
 page_alloc(int alloc_flags)
 {
<span class="token deleted">-	// Fill this function in</span>
<span class="token deleted">-	return 0;</span>
<span class="token inserted">+	if (!page_free_list)	// if page_free_list == NULL</span>
<span class="token inserted">+		return NULL;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	struct PageInfo *page_allocated = page_free_list;</span>
<span class="token inserted">+	page_free_list = page_free_list->pp_link;</span>
<span class="token inserted">+	page_allocated->pp_link = NULL;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (alloc_flags &amp; ALLOC_ZERO)</span>
<span class="token inserted">+		memset(page2kva(page_allocated), 0, PGSIZE);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	return page_allocated;</span>
 }
 
 //
@@ -288,6 +409,18 @@ page_free(struct PageInfo *pp)
 	// Fill this function in
 	// Hint: You may want to panic if pp->pp_ref is nonzero or
 	// pp->pp_link is not NULL.
<span class="token inserted">+</span>
<span class="token inserted">+	if (pp->pp_link)		// pp->pp_link is not NULL, double free</span>
<span class="token inserted">+		panic("Double free page %u, pvaddr:%x, ppaddr:%x\n",\</span>
<span class="token inserted">+			(uint32_t)(pp-pages), page2kva(pp), page2pa(pp));</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (pp->pp_ref)			// pp->pp_ref is nonzero</span>
<span class="token inserted">+		panic("Free a page in use, pnum:%u, pvaddr:%x, ppaddr:%x\n",\</span>
<span class="token inserted">+			(uint32_t)(pp-pages), page2kva(pp), page2pa(pp));</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	pp->pp_link = page_free_list;</span>
<span class="token inserted">+	page_free_list = pp;</span>
<span class="token inserted">+	return;</span>
 }
 
 //

</pre><h2 class="mume-header" id="virtual-memory" ebook-toc-level-2="" heading="Virtual Memory">Virtual Memory</h2>

<p>In x86 terminology, a <strong><em>virtual address</em></strong> consists of a <strong><em>segment selector</em></strong> and an <strong><em>offset</em></strong> within the segment. A <strong><em>linear address</em></strong> is what you get after segment translation but before page translation. A <strong><em>physical address</em></strong> is what you finally get after both segment and page translation and what ultimately goes out on the hardware bus to your RAM. ( <a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab2/">Ref</a> )</p>
<p>A C pointer is the “offset” component of the virtual address. In boot/boot.S, we installed a Global Descriptor Table (GDT) that effectively disabled segment translation by setting all segment base addresses to 0 and limits to 0xffffffff. Hence the “selector” has no effect and the linear address always equals the offset of the virtual address. ( <a href="https://pdos.csail.mit.edu/6.828/2017/labs/lab2/">Ref</a> )</p>
<p>The figure below gives a more straightforward explanation.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<h3 class="mume-header" id="exercise-3" ebook-toc-level-3="" heading="Exercise 3">Exercise 3</h3>

<blockquote>
<p>Q : Use the xp command in the QEMU monitor and the x command in GDB to inspect memory at corresponding physical and virtual addresses and make sure you see the same data.</p>
</blockquote>
<p>In <code>entry_pgdir</code>, the linear address in the range 0xF0000000 through 0xF0400000 is mapped to physical addresses 0x00000000 through 0x00400000. So we check ten DWORDss beginning from 0x100000 in physical address or 0xf0100000 in linear address, i.e., the first ten DWORDs in kernel. As shown below, they are the same.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">QEMU 2.5.0 monitor - <span class="token function">type</span> <span class="token string">'help'</span> <span class="token keyword">for</span> <span class="token function">more</span> information
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> xp/10x 0x100000
0000000000100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0000000000100010: 0x34000004 0x6000b812 0x220f0011 0xc0200fd8
0000000000100020: 0x0100010d 0xc0220f80
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> x/10x 0xf0100000
f0100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766
f0100010: 0x34000004 0x6000b812 0x220f0011 0xc0200fd8
f0100020: 0x0100010d 0xc0220f80
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> 
</pre><h3 class="mume-header" id="question-1" ebook-toc-level-3="" heading="Question 1">Question 1</h3>

<blockquote>
<p>Q : Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?<br>
        <code>mystery_t x;</code><br>
        <code>char* value = return_a_pointer();</code><br>
        <code>*value = 10;</code><br>
        <code>x = (mystery_t) value;</code></p>
</blockquote>
<p><code>x</code> is a pointer in C language, which should be a virtual address, namely, <code>uintptr_t</code>.</p>
<h3 class="mume-header" id="exercise-4" ebook-toc-level-3="" heading="Exercise 4">Exercise 4</h3>

<blockquote>
<p>Q : In the file kern/pmap.c, you must implement code for the following functions.<br>
        <code>pgdir_walk()</code><br>
        <code>boot_map_region()</code><br>
        <code>page_lookup()</code><br>
        <code>page_remove()</code><br>
        <code>page_insert()</code><br>
check_page(), called from mem_init(), tests your page table management routines. You should make sure it reports success before proceeding.</p>
</blockquote>
<ul>
<li><strong>What is <a href="https://en.wikipedia.org/wiki/Page_table#Multilevel_page_table"><em>Two-level Page Table</em></a> ?</strong></li>
</ul>
<p>To finish this exercise, we need to how the page system works in JOS. To mantain the map between linear address and physical address while avoiding using too much memory on page tables, JOS adopts a two-level page system.</p>
<p>In a two-level page system, a linear address is decomposed as below.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<p>To be transformed to a physical address, a linear address goes through the following procedure.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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3t7eKN3h4WFPZwAgc2UulZC5R48ePX78eJRuX1/f0NCQpzMAkLkyl0rI3I6Ojijdrq6unp6ewcFBT2cAIHNlLpWQuc8///xrr7327rvvnjp1qr+/39MZAMhcmYvMBQCZO3lMnz79/PnzMheZCwBUVOYuWLDg5MmTMndsnTt3bsuWLTNnzqypqWlpadm3b1+2tHKqq6vr6ura2tri/dOt3/nOd+bOnRvXNzQ07NixY2hoKPeBr7766rx58/LupKqqqra2dt26dbl7yLtpxYoVH374YbGzz5gx49577y382BEf2/z5819//XWZCwAyd3K45557Dhw4IHPHULRp9Gjef76VK90R/2uu9evXp8bNuz76NXe3ixcv3rRpU7E7Sfcw4k2zZs3q7e0tcfY1a9aM+tjC5s2bI9llLgDI3Mlhz549bW1tMncMfetb34pH2Nra+vvf//7ixYtr166Ni4sWLcqmZO6d33vvvbhYU1MTxytXrqytrX355ZfjODosfUs1vdvRo0fj4o9+9KPCO0k3xQcW3nTmzJm4z7jY3t4+6tlHvTXOHhffeustmQsAMncSGBgYaGpqOnHihMwdK83NzfEIcy8ViNZcsWJFZ2fniCkZ18fF3KsRcg4dOhTX33vvvenitm3bsomZvZO4sljmhl//+tdxce7cuSPemhJ5+fLl5Ty2dHHLli0yFwBk7uRw+PDhxsbGhx566JNPPpG5X111dXWJRzjiCwMefvjh7PtElaa+/OKLL9I1S5YsiWsuXrxY7E7a2tpGTNV0Td73a7NaW1vPnj1bzmOLs8fFxYsXy1wAkLmTRnd3d3RSxO60ieG2226bIpm7cOHCF154Ie99rly5sn///rh1w4YN6Zra2trsfWZ/ziz9oNjAwECJzM29+KHwSx33sHPnzjIfW/bbxjIXAGQuY2yCZ+78+fPjEX7wwQfp4unTp1tbWwtftPD+++83NDTE8Xe+851009e//vVo1myw5r4Lm5fOhS1b7KaIubg4Z86cEW89fPjwiC94KHxshcUscwFA5jK1Mnfnzp3xCFesWHHu3LmhoaE1a9bExdzvKMiGZnoBbu5ny+6666443rZtWxz/4Ac/iOPGxsYS380dNXOjmNevX399P4KW99hy7xAhLnMBQOYyFTM3/VRf3gsADh48OGJobtiwIf3Or9///vfpB8Kyvve976V3W758eeFrc8t87e+ov1Cs2Ot6s48tLl64cCG9llfmAoDMZSpmbvrvITZt2jRjxoyqqqolS5YcOnSo2Ddiz549W1dXl3sZbtRwes3DvHnzHn/88dy7bd++Pa48cuTINWVubW3t2rVri/33EDU1NfEIv/GNbxR7XW/eY0u/0uGb3/ymzAUAmcsUzdwxl36NbuEPq91McfZ4DO+9957MBQCZi8wdM3feeed99903jg9gy5YtS5cundRfQ5kLADJX5k44R44cyf1XauMizn748GGZCwAyF5mLzAUAmYvMReYCgMyVuSBzAUDmylyQuQAgc2UuMhcAZK7MlbnIXACQuYxB5sL1kbkAIHMntMHBwZ6enq6urqNHj3Z0dDwP5YnVEmsmVk6sn1hFRgkAZO7EMjQ01NfXd+rUqePHj0e1vAblidUSayZWTqyfWEVGCQBk7sQyPDzc39/f29sbvdLV1fUulCdWS6yZWDmxfmIVGSUAkLkTy6VLl4aGhqJU+vr6enp6TkF5YrXEmomVE+snVpFRAgCZO7FcvXo1GmV4eDhiZXBwsB/KE6sl1kysnFg/sYqMEgDIXAAAZC4AAMhcAACQuQAAIHMBAEDmAgAgc2UuAAAyFwAAZC4AAMhcAACQuQAAIHMBAJC5AAAgcwEAQOYCAIDMBQAAmQsAgMyVuQAAyFwAAJC5AAAgcwEAQOYCAIDMBQBA5gIAgMwFAACZCwAANyFzAQCgYshcAABkLgAATAb/D7CutWdsqmhnAAAAAElFTkSuQmCC"></center>
<p>When referring to a place in memory, the hardware does this translation for us. What we need to do is to maintain this map properly, i.e., setting or resetting the entry correctly. In <code>pgdir_walk(pde_t *, const void *, int)</code>, we always give the page where a page table resides a loose security restriction. Because a page table may contain entries used by kernel and entries used by user programs at the same time. Thus we can’t prevent user programs from accessing those entries.</p>
<p>The code modified is show in the following <code>git diff</code> log.</p>
<pre data-role="codeBlock" data-info="git" class="language-git">diff --git a/kern/pmap.c b/kern/pmap.c
index 88356e4..34589aa 100644
<span class="token deleted">--- a/kern/pmap.c</span>
<span class="token inserted">+++ b/kern/pmap.c</span>
@@ -133,7 +133,7 @@ mem_init(void)
 	i386_detect_memory();
 
 	// Remove this line when you're ready to test this function.
<span class="token deleted">-	panic("mem_init: This function is not finished\n");</span>
<span class="token inserted">+	//panic("mem_init: This function is not finished\n");</span>
 
 	//////////////////////////////////////////////////////////////////////
 	// create initial page directory.
@@ -456,11 +456,38 @@ page_decref(struct PageInfo* pp)
 // Hint 3: look at inc/mmu.h for useful macros that mainipulate page
 // table and page directory entries.
 //
<span class="token inserted">+// Hint 4: all pointers in C are virtual addresses but all addresses in</span>
<span class="token inserted">+// page dir and page table are physical address</span>
<span class="token inserted">+//</span>
 pte_t *
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
 	// Fill this function in
<span class="token deleted">-	return NULL;</span>
<span class="token inserted">+	pde_t *pd_entry = &amp;pgdir[PDX(va)];</span>
<span class="token inserted">+	pte_t *pgtable = NULL;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// if the relevant page table page exists</span>
<span class="token inserted">+	if ((physaddr_t)*pd_entry &amp; PTE_P) {</span>
<span class="token inserted">+		pgtable = (pte_t *)(KADDR(PTE_ADDR(*pd_entry)));</span>
<span class="token inserted">+		return &amp;pgtable[PTX(va)];</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// if the relevant page table doesn't exist and create == false</span>
<span class="token inserted">+	if (create == false)</span>
<span class="token inserted">+		return NULL;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// allocate a new page table, use ALLOC_ZERO to clear the page</span>
<span class="token inserted">+	// page_alloc guarantees NULL is returned on allocation failure</span>
<span class="token inserted">+	struct PageInfo *new_page_info = page_alloc(ALLOC_ZERO);</span>
<span class="token inserted">+	if (new_page_info == NULL)</span>
<span class="token inserted">+		return NULL;</span>
<span class="token inserted">+	++(new_page_info->pp_ref);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// pages of kernel and users may be allocated on one page table</span>
<span class="token inserted">+	// so it's convenient to give page table a user level privilige</span>
<span class="token inserted">+	*pd_entry = (pde_t)((uintptr_t)page2pa(new_page_info) | PTE_P | PTE_W | PTE_U);</span>
<span class="token inserted">+	pgtable = (pte_t *)page2kva(new_page_info);</span>
<span class="token inserted">+	return &amp;pgtable[PTX(va)];</span>
 }
 
 //
@@ -477,7 +504,16 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
<span class="token deleted">-	// Fill this function in</span>
<span class="token inserted">+	for (size_t alloc_size = 0; alloc_size &lt; size; alloc_size += PGSIZE) {</span>
<span class="token inserted">+		pte_t *pt_entry = pgdir_walk(pgdir, (void *)va, true);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		if (pt_entry == NULL)</span>
<span class="token inserted">+			panic("Page allocation failed!");</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		*pt_entry = pa | perm | PTE_P;</span>
<span class="token inserted">+		va += PGSIZE;</span>
<span class="token inserted">+		pa += PGSIZE;</span>
<span class="token inserted">+	}</span>
 }
 
 //
@@ -498,6 +534,13 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 // frequently leads to subtle bugs; there's an elegant way to handle
 // everything in one code path.
 //
<span class="token inserted">+// Corner-case answer: The hint actually remind us to consider such a condition</span>
<span class="token inserted">+// that the same pp is re-inserted at the same virtual address "va" and the "pp"</span>
<span class="token inserted">+// is only referred to by the "va" previously, namely, pp->pp_ref == 0. Under</span>
<span class="token inserted">+// such a condition, if we call page_remove() before we increment pp->ref,</span>
<span class="token inserted">+// page_remove() will free pp back to free_page_list so that our pte will point</span>
<span class="token inserted">+// to a free page. if we increment pp->pp_ref first, we can avoid this mistake.</span>
<span class="token inserted">+//</span>
 // RETURNS:
 //   0 on success
 //   -E_NO_MEM, if page table couldn't be allocated
@@ -509,6 +552,16 @@ int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
 	// Fill this function in
<span class="token inserted">+	pte_t *pt_entry = pgdir_walk(pgdir, va, true);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (pt_entry == NULL)</span>
<span class="token inserted">+		return -E_NO_MEM;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	++(pp->pp_ref);</span>
<span class="token inserted">+	if (*pt_entry &amp; PTE_P)</span>
<span class="token inserted">+		page_remove(pgdir, va);		// page_remove() will call tlb_invalidate()</span>
<span class="token inserted">+</span>
<span class="token inserted">+	*pt_entry = page2pa(pp) | perm | PTE_P;</span>
 	return 0;
 }
 
@@ -527,7 +580,16 @@ struct PageInfo *
 page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 {
 	// Fill this function in
<span class="token deleted">-	return NULL;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	pte_t *pt_entry = pgdir_walk(pgdir, va, false);</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (pt_entry == NULL)</span>
<span class="token inserted">+		return NULL;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (pte_store)	// if pte_store is not zero</span>
<span class="token inserted">+		*pte_store = pt_entry;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	return pa2page(PTE_ADDR(*pt_entry));</span>
 }
 
 //
@@ -549,6 +611,14 @@ void
 page_remove(pde_t *pgdir, void *va)
 {
 	// Fill this function in
<span class="token inserted">+	pte_t *pt_entry;</span>
<span class="token inserted">+	struct PageInfo *mapped_page = page_lookup(pgdir, va, &amp;pt_entry);</span>
<span class="token inserted">+	if (mapped_page == NULL)	// no physical page mapped, do nothing</span>
<span class="token inserted">+		return;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	page_decref(mapped_page);</span>
<span class="token inserted">+	*pt_entry = 0;</span>
<span class="token inserted">+	tlb_invalidate(pgdir, va);</span>
 }
 
 //

</pre><h2 class="mume-header" id="kernel-address-space" ebook-toc-level-2="" heading="Kernel Address Space">Kernel Address Space</h2>

<p>In x86 page tables, we use permission bits to allow user programs only to access their own part of the address space. Otherwiese, bugs in user programs might overwrite kernel data, causing a crash or more subtle malfunction; user programs might also be able to steal other environments’ private data.</p>
<p>Here we use <code>PTE_U</code> and <code>PTE_W</code> to set permission bits. Since the name of <code>PTE_W</code> may be a little confusing, we should keep in mind that when the processor is executing at supervisor level, all pages are addressable, i.e., readable and writable. <code>PTE_U</code> means user programs can access the corresponding memory. It effectively means the corresponding memory is user-readable. <code>PTE_W</code> means user program can write data into the corresponding memroy.</p>
<p>In lab 2, we are ask to set our permission bits as the following.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<h3 class="mume-header" id="exercise-5" ebook-toc-level-3="" heading="Exercise 5">Exercise 5</h3>

<blockquote>
<p>Q : Fill in the missing code in mem_init() after the call to check_page().<br>
Your code should now pass the check_kern_pgdir() and check_page_installed_pgdir() checks.</p>
</blockquote>
<p>In this exercise, we use <code>boot_map_region(pde_t *, uintptr_t, size_t, physaddr_t, int)</code> to mapp some linear addresses as required and then load <code>kern_pgdir</code> to <code>CR3</code> to replace <code>entry_pgdir</code>.</p>
<p>In this exercise we finish <code>mem_init()</code>, the test result is shown below.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">***
*** Use Ctrl-a x to <span class="token keyword">exit</span> qemu
***
qemu-system-i386 -nographic -drive file<span class="token operator">=</span>obj/kern/kernel.img,index<span class="token operator">=</span>0,media<span class="token operator">=</span>disk,format<span class="token operator">=</span>raw -serial mon:stdio -gdb tcp::26000 -D qemu.log
6828 decimal is 15254 octal<span class="token operator">!</span>
Physical memory: 131072K available, base <span class="token operator">=</span> 640K, extended <span class="token operator">=</span> 130432K
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_alloc<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_kern_pgdir<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_installed_pgdir<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
Welcome to the JOS kernel monitor<span class="token operator">!</span>
Type <span class="token string">'help'</span> <span class="token keyword">for</span> a list of commands.
K<span class="token operator">></span>
</pre><p>The code modified is shown in the following <code>git diff</code> log.</p>
<pre data-role="codeBlock" data-info="git" class="language-git">diff --git a/kern/pmap.c b/kern/pmap.c
index 34589aa..f22a5e5 100644
<span class="token deleted">--- a/kern/pmap.c</span>
<span class="token inserted">+++ b/kern/pmap.c</span>
@@ -182,6 +182,7 @@ mem_init(void)
 	//      (ie. perm = PTE_U | PTE_P)
 	//    - pages itself -- kernel RW, user NONE
 	// Your code goes here:
<span class="token inserted">+	boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR((void *)pages), PTE_U);</span>
 
 	//////////////////////////////////////////////////////////////////////
 	// Use the physical memory that <span class="token string">'bootstack'</span> refers to as the kernel
@@ -194,6 +195,7 @@ mem_init(void)
 	//       overwrite memory.  Known as a <span class="token string">"guard page"</span>.
 	//     Permissions: kernel RW, user NONE
 	// Your code goes here:
<span class="token inserted">+	boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR((void *)bootstack), PTE_W);</span>
 
 	//////////////////////////////////////////////////////////////////////
 	// Map all of physical memory at KERNBASE.
@@ -203,6 +205,12 @@ mem_init(void)
 	// we just set up the mapping anyway.
 	// Permissions: kernel RW, user NONE
 	// Your code goes here:
<span class="token inserted">+	// Actually 0xFFFFFFFF is 2^32-1. But you aren't able to represent 2^32</span>
<span class="token inserted">+	// in an integer on 32-bit system. So 0xFFFFFFFF-KERNBASE is one less</span>
<span class="token inserted">+	// than the size we want. Luckily, boot_map_region() will round up the</span>
<span class="token inserted">+	// for us and everything goes fine since 0xFFFFFFFF-KERNBASE is </span>
<span class="token inserted">+	// representable on 32-bit system.</span>
<span class="token inserted">+	boot_map_region(kern_pgdir, KERNBASE, 0xFFFFFFFF-KERNBASE, (physaddr_t)0x0, PTE_W);</span>
 
 	// Check that the initial page directory has been set up correctly.
 	check_kern_pgdir();
</pre><h3 class="mume-header" id="question-2" ebook-toc-level-3="" heading="Question 2">Question 2</h3>

<blockquote>
<p>Q : What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point?</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">Entry</th>
<th style="text-align:center">Base Virtual Address</th>
<th style="text-align:center">Points to (logically)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[0x3BC, 0x3BD)</td>
<td style="text-align:center">[0xEF000000, 0xEF400000)</td>
<td style="text-align:center"><code>pages</code> array</td>
</tr>
<tr>
<td style="text-align:center">[0x3BF, 0x3C0)</td>
<td style="text-align:center">[0xEFFF8000, 0xF0000000)</td>
<td style="text-align:center">bootstack</td>
</tr>
<tr>
<td style="text-align:center">[0x3C0, 0x3FF)</td>
<td style="text-align:center">[0xF0000000, 0x100000000)</td>
<td style="text-align:center">kernel</td>
</tr>
</tbody>
</table>
<h3 class="mume-header" id="question-3" ebook-toc-level-3="" heading="Question 3">Question 3</h3>

<blockquote>
<p>Q : We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel’s memory? What specific mechanisms protect the kernel memory?</p>
</blockquote>
<p>We didn’t toggle on the <code>PTE_U</code> bit in those page table entry that point to kernel’s memroy. So once a user program wants to access memory that belongs to kernel, CPU will detect it and notify JOS.</p>
<h3 class="mume-header" id="question-4" ebook-toc-level-3="" heading="Question 4">Question 4</h3>

<blockquote>
<p>Q : What is the maximum amount of physical memory that this operating system can support? Why?</p>
</blockquote>
<p>JOS can support 2GB memory at most. JOS use 4MB memory to store a PageInfo array. Each PageInfo struct consumes 8 Bytes, containing information of one 4KB page. So 2<sup>19</sup> PageInfo structs can be stored at most, which record information of 2G memory.</p>
<h3 class="mume-header" id="question-5" ebook-toc-level-3="" heading="Question 5">Question 5</h3>

<blockquote>
<p>Q : How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?</p>
</blockquote>
<p>If we actually had the maximum amout of physical memory, we need 4MB for the PageInfo array, 4KB for page directory and 4BM at most for page tables. The memory for the PageInfo array is hardcoded in JOS so its size doesn’t change even though it’s not fully used in lab 2 JOS, which only has 128M memory. The memroy for the page directory can’t not be ruled out, either. But we can save our memory by allocating a page for a page table only when we really need it. It’s the reason why we use a two-level paging system.</p>
<h3 class="mume-header" id="question-6" ebook-toc-level-3="" heading="Question 6">Question 6</h3>

<blockquote>
<p>Q : Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?</p>
</blockquote>
<p>After <code>jmp *%eax</code> in <code>entry.S</code>, we transition to running at an EIP above KERNBASE. In manully established page tables that reside in <code>entrypgdir.c</code>, we map 4MB from 0x00000000 and 4MB from KERNBASE in linear address space to 4MB from 0x000000 in physical memory address. Therefore, after enabling paging, kernel can still run at a low EIP.</p>
<p>We hope kernel to run at the top of 4GB linear address space. So we want to kernel transitions to running at an EIP above KERNBASE. Furthermore, we will use<code>kern_pgdir</code> and discar <code>entry_pgdir</code> after <code>mem_init()</code>. In <code>mem_init()/kern_pgdir</code>, we didn’t map 4MB memory from 0x00000000 in linear address space to any physcial memory. So it’s also necessary for JOS to run at an EIP above KERNBASE before we switch our page directory.</p>
<h2 class="mume-header" id="challenges" ebook-toc-level-2="" heading="Challenges">Challenges</h2>

<h3 class="mume-header" id="challenge-1" ebook-toc-level-3="" heading="Challenge 1">Challenge 1</h3>

<blockquote>
<p>We consumed many physical pages to hold the page tables for the KERNBASE mapping. Do a more space-efficient job using the PTE_PS (“Page Size”) bit in the page directory entries.</p>
</blockquote>
<p>For details about <em>4MB page</em> mechanism, you can refer to section 3.6, 3.7 and 10.9 in <strong>INTEL 80386 PROGRAMMER’S REFERENCE MANUAL 1986</strong>. Below is a brief explanation of it.</p>
<p>Since one entry corresponds to 4MB memory, we only need one-level page table, which means we discard page table and retain the page directory. Now we decompose linear addresses in a new and simpler way as show below.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<p>The translation between linear addresses and physical addresses is simpler, too, as shown below.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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A1YoIJKMYMAKBUSSSAKsUACRBFihACIJsEIBRBJghQKIJCMYrFAAkWQEgxUKIJKMYBBJACLJCAaRBCCSjGAQSQAiyQgGkWSFAiLJCAasUEAkGcGAFQqIJCMYsEIBkWQEA1YoIJJEEmCFAogkwAoFEEmAFQogkgArFEAkGcFghQKIJCMYRBKASDKCQSQBiCQjGEQSgEgygkEkAYgkIxiwQgGRZAQDViggkoxgwAoFRJIRDFihgEgyggErFBBJIgmwQgFEEmCFAogkwAoFEElGMFihACLJCAYrFEAkGcEgkgBEkhEMIglAJBnBIJIARJIRDCIJQCQZwYAVCogkIxiwQgGRZAQDViggkoxgwAoFRJJIAqxQAJEEWKEAIgmwQgFEEmCFAogkIxisUACRZASDFQogkoxgEEkAIskIBpEEIJKMYBBJACLJCAasUEAkGcGAFQqIJCMYsEIBkWQEA1YoIJKMYMAKvXw9PT01NTXZT3nKX/z7v/97buczzzyT25/3bqGysnLatGn33HPPF198MebXM6moqKiurl61atWY73bF/xFHc24jkoxgwAot1eLFi/MCIpcUy5cvz+286667ikRSzooVK0rpldWrV4skEElGMFih5esHP/hBY2PjmJG0aNGiysrKM2fOxJ54W1FRcfvtt4+OpNxH/c///E9crKqqKtQrafudd96J7erq6nTx008/bWlpiYtxrIULFx46dCj3UY888khdXV3cvV/96ld5x3ruueeampriQ5qbm/fu3VskkopcFTdbX18fjVjkbqT3/Nd//dfa2tq4J93d3Zs3b473mTlzZnwil3R/QCQZwSCSrhu//vWvI33eeuutMSNp586duWfc0nNtO3bsKBJJqX6WLFlSvFfS4XKRFEWSfaRn9uzZaf/u3btzO2+99dbsLbz22mt5jw9l06r0SEpWrlxZ5G7kHSgaKLt9SfcHRJIRDCLp+vD11183NTXdd999o3siXezr64uESs+43XXXXbH9hz/8ofjTbS0tLfE+xaMkaWtry3uf3/72t9kHohYtWhQXt2zZEtvt7e3Z40aHxXZHR0dsv/nmm4WevCvyXFu6mG78008/LXI30ns+99xzaX+qxt/85jfpZViXdH9AJBnBIJKuD+vWrWtubv7mm28KRdIf//jHZcuWRQpE90Qhtba2xp7ikRTvtm3btiK9Eu9Q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"></center>
<p>To inform CPU that you are using big page, you need to toggle bits on in two places. The first one is the <strong>PSE (page size extensions) flag</strong>, which is bit 4 of CR4 (introduced in Pentium<sup>®</sup> processor). The other is the <strong>PS (page size)</strong> in page directory entries. Again, the entries become simpler, too, as shown below.</p>
<center>
<img src="data:image/png;charset=utf-8;base64,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"></center>
<p>Because when enabling or diabling large page sizes, the TLBs must be invalidated (flushed) after the <strong>PSE flag</strong> in control register <strong>CR4</strong> has been set or cleared. Otherwise, incorrect page translation might occur due to the processor using outdated page translation information stored in the TLBs. Further more, loading a new value into <strong>CR3</strong> is one method to flush all TLBs. Thus, We need to set <strong>PSE flag</strong> before we load new value into <strong>CR3</strong>.</p>
<p>Since tests in <code>mem_init()</code> are created with small page size concept in mind that are not suitable for testing 4MB page system, so I comment most of this tests to avoid JOS <code>panic()</code> and I did write new tests for 4MB page system. When switch JOS to big page mode, I didn’t change the value of <code>PGSIZE</code> directly. Instead, I define a new macro named <code>BIG_PGSIZE</code> whose value is 4MB and modified other codes base on <code>BIG_PGSIZE</code>. By doing this, I didn’t need to change macros for JOS memory layout, whose value are derived using <code>PGSIZE</code>. One thing we should keep in mind is that although I succeed in switching JOS to big page mode and all functions implemented in lab 1 and lab 2 work fine, we haven’t finished the transition to big page mode yet. It’s a coincidence that our memory layout design using small pages gets along well with big pages. If we want to implemente more complicated functions related to memory management, we need to re-design JOS’s memory layout.</p>
<p>The result is shown below, JOS executes properly.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">***
*** Use Ctrl-a x to <span class="token keyword">exit</span> qemu
***
qemu-system-i386 -nographic -drive file<span class="token operator">=</span>obj/kern/kernel.img,index<span class="token operator">=</span>0,media<span class="token operator">=</span>disk,format<span class="token operator">=</span>raw -serial mon:stdio -gdb tcp::26000 -D qemu.log
6828 decimal is 15254 octal<span class="token operator">!</span>
Physical memory: 131072K available, base <span class="token operator">=</span> 640K, extended <span class="token operator">=</span> 130432K
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
Welcome to the JOS kernel monitor<span class="token operator">!</span>
Type <span class="token string">'help'</span> <span class="token keyword">for</span> a list of commands.
K<span class="token operator">></span> <span class="token function">help</span> list
<span class="token function">help</span>
-SYNOPSIS:
    <span class="token function">help</span> <span class="token punctuation">{</span>list <span class="token operator">|</span> <span class="token function">command</span> name<span class="token punctuation">}</span>
-DESCRIPTION:
    list: display all <span class="token function">help</span> information of all commands.
    <span class="token function">command</span> name: display <span class="token function">help</span> information of given name

kerninfo
Display information about the kernel

backtrace
Display the current call stack

mappings
-SYNOPSIS:
    mappings <span class="token punctuation">{</span>show laddr uaddr<span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token punctuation">{</span>clear vaddr <span class="token punctuation">[</span>size<span class="token operator">==</span>1<span class="token punctuation">]</span><span class="token punctuation">}</span>
             <span class="token operator">|</span> <span class="token punctuation">{</span>set perm vaddr <span class="token punctuation">[</span>size<span class="token operator">==</span>1<span class="token punctuation">]</span><span class="token punctuation">}</span>
-DESCRIPTION:
    show: display page mappings <span class="token keyword">in</span> <span class="token punctuation">[</span>laddr, uaddr<span class="token punctuation">)</span>
    clear: <span class="token function">clear</span> privilege of size<span class="token punctuation">(</span>in page<span class="token punctuation">)</span> pages from vaddr.
           The privilege is <span class="token keyword">set</span> to PTE_U <span class="token operator">==</span> 0 and PTE_W <span class="token operator">==</span> 0.
    set: <span class="token keyword">set</span> privilege of size<span class="token punctuation">(</span>in page<span class="token punctuation">)</span> pages from vaddr.
         The privilege <span class="token string">'perm'</span> can be specified by a number or a
         two-character string containing <span class="token string">'u'</span><span class="token punctuation">(</span>PTE_U<span class="token punctuation">)</span>, <span class="token string">'w'</span><span class="token punctuation">(</span>PTE_W<span class="token punctuation">)</span> or
         <span class="token string">'-'</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span>
    All addresses will be rounded down to page alignment.

dump
-SYNOPSIS:
    dump addr_type addr <span class="token punctuation">[</span>size<span class="token operator">==</span>1<span class="token punctuation">]</span>
-DESCRIPTION:
    addr_type: <span class="token string">'-v'</span> <span class="token keyword">for</span> virtual address, '-p <span class="token keyword">for</span> physical address
    addr: beginning address
    size: memory size <span class="token keyword">in</span> dwords<span class="token punctuation">(</span>4 bytes<span class="token punctuation">)</span>

K<span class="token operator">></span>
</pre><p>The code modified for 4MB paging is shown in the following <code>git diff</code> log.</p>
<pre data-role="codeBlock" data-info="git" class="language-git">diff --git a/inc/mmu.h b/inc/mmu.h
index 093c8a6..7f6df3f 100644
<span class="token deleted">--- a/inc/mmu.h</span>
<span class="token inserted">+++ b/inc/mmu.h</span>
<span class="token coord">@@ -26,25 +26,55 @@</span>
 // To construct a linear address la from PDX(la), PTX(la), and PGOFF(la),
 // use PGADDR(PDX(la), PTX(la), PGOFF(la)).
 
<span class="token inserted">+/*</span>
<span class="token inserted">+ * In big page table,</span>
<span class="token inserted">+ * a linear address 'la' has a two-part structure as follows"</span>
<span class="token inserted">+ * +-------10-------+--------------------22----------------+</span>
<span class="token inserted">+ * | Page Directory |          Offset within Page          |</span>
<span class="token inserted">+ * |      Index     |                                      |</span>
<span class="token inserted">+ * +----------------+--------------------------------------+</span>
<span class="token inserted">+ * \--BIG_PDX(la)--/ \-------------BIG_PGOFF(la)-----------/</span>
<span class="token inserted">+ * \-BIG_PGNUM(la)-/</span>
<span class="token inserted">+ * </span>
<span class="token inserted">+ * The BIG_PDX, BIG_PGOFF, and BIG_PGNUM macors decompose linear address as</span>
<span class="token inserted">+ * shown. To construct a linear address la from BIG_PDX(la), BIG_PGOFF(la),</span>
<span class="token inserted">+ * use BIG_PGADDR(BIG_PDX(la), BIG_PGOFF(la)).</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+</span>
 // page number field of address
 #define PGNUM(la)	(((uintptr_t) (la)) >> PTXSHIFT)
 
<span class="token inserted">+// big page number field of address</span>
<span class="token inserted">+#define BIG_PGNUM(la) (((uintptr_t) (la)) >> BIG_PGSHIFT)</span>
<span class="token inserted">+</span>
 // page directory index
 #define PDX(la)		((((uintptr_t) (la)) >> PDXSHIFT) &amp; 0x3FF)
 
<span class="token inserted">+// big page directory index</span>
<span class="token inserted">+#define BIG_PDX(la) ((((uintptr_t) (la)) >> BIG_PGSHIFT) &amp; 0x3FF)</span>
<span class="token inserted">+</span>
 // page table index
 #define PTX(la)		((((uintptr_t) (la)) >> PTXSHIFT) &amp; 0x3FF)
 
 // offset in page
 #define PGOFF(la)	(((uintptr_t) (la)) &amp; 0xFFF)
 
<span class="token inserted">+// offset in big page</span>
<span class="token inserted">+#define BIG_PGOFF(la) (((uintptr_t) (la)) &amp;0x3FFFFF)</span>
<span class="token inserted">+</span>
 // construct linear address from indexes and offset
 #define PGADDR(d, t, o)	((void*) ((d) &lt;&lt; PDXSHIFT | (t) &lt;&lt; PTXSHIFT | (o)))
 
<span class="token inserted">+// construct linear address for big page indexes and offset</span>
<span class="token inserted">+#define BIG_PGADDR(d, o) ((void *) ((d) &lt;&lt; BIG_PGSHIFT | (o)))</span>
<span class="token inserted">+</span>
 // Page directory and page table constants.
 #define NPDENTRIES	1024		// page directory entries per page directory
<span class="token deleted">-#define NPTENTRIES	1024		// page table entries per page table</span>
<span class="token inserted">+#define NPTENTRIES	1024		// page table entries per page table, in big page</span>
<span class="token inserted">+                                // there is only page directory, no page table.</span>
 
<span class="token inserted">+#define BIG_PGSHIFT 22                  // log(BIG_PGSIZE)</span>
<span class="token inserted">+#define BIG_PGSIZE  (1 &lt;&lt; BIG_PGSHIFT)  // bytes mapped by a page</span>
 #define PGSIZE		4096		// bytes mapped by a page
 #define PGSHIFT		12		// log2(PGSIZE)
 
<span class="token coord">@@ -75,6 +105,9 @@</span>
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)	((physaddr_t) (pte) &amp; ~0xFFF)
 
<span class="token inserted">+// Address in page directory entry</span>
<span class="token inserted">+#define PDE_ADDR(pde)	((physaddr_t) (pde) &amp; ~0x3FFFFF)</span>
<span class="token inserted">+</span>
 // Control Register flags
 #define CR0_PE		0x00000001	// Protection Enable
 #define CR0_MP		0x00000002	// Monitor coProcessor
diff --git a/kern/pmap.c b/kern/pmap.c
index f22a5e5..498330f 100644
<span class="token deleted">--- a/kern/pmap.c</span>
<span class="token inserted">+++ b/kern/pmap.c</span>
@@ -50,8 +50,11 @@ i386_detect_memory(void)
 	else
 		totalmem = basemem;
 
<span class="token deleted">-	npages = totalmem / (PGSIZE / 1024);</span>
<span class="token deleted">-	npages_basemem = basemem / (PGSIZE / 1024);</span>
<span class="token inserted">+	// in big page system, a page is 4MB, which can cover memory much</span>
<span class="token inserted">+	// more than basemem. So npages_basemem should be zero and can't</span>
<span class="token inserted">+	// be relied on.</span>
<span class="token inserted">+	npages = totalmem / (BIG_PGSIZE / 1024);</span>
<span class="token inserted">+	npages_basemem = basemem / (BIG_PGSIZE / 1024);</span>
 
 	cprintf(<span class="token string">"Physical memory: %uK available, base = %uK, extended = %uK\n"</span>,
 		totalmem, basemem, totalmem - basemem);
@@ -105,7 +108,7 @@ boot_alloc(uint32_t n)
 	// LAB 2: Your code here.
 	result = nextfree;
 	nextfree = ROUNDUP(nextfree + n, PGSIZE);
<span class="token deleted">-	if ((uint32_t)nextfree - KERNBASE > npages*PGSIZE) {</span>
<span class="token inserted">+	if ((uint32_t)nextfree - KERNBASE > npages*BIG_PGSIZE) {</span>
 		panic(<span class="token string">"Out of Memory!\n"</span>);
 		nextfree = result;
 		result = NULL;
@@ -131,12 +134,15 @@ mem_init(void)
 
 	// Find out how much memory the machine has (npages &amp; npages_basemem).
 	i386_detect_memory();
<span class="token deleted">-</span>
<span class="token inserted">+	</span>
 	// Remove this line when you're ready to test this function.
 	//panic(<span class="token string">"mem_init: This function is not finished\n"</span>);
 
 	//////////////////////////////////////////////////////////////////////
 	// create initial page directory.
<span class="token inserted">+	// in boot_alloc, we still use small page alignment, since now free page</span>
<span class="token inserted">+	// list has not been established and big page has not been enabled yet.</span>
<span class="token inserted">+	// By doing so we can save memory and possibly gain better performance.</span>
 	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
 	memset(kern_pgdir, 0, PGSIZE);
 
@@ -147,7 +153,7 @@ mem_init(void)
 	// following line.)
 
 	// Permissions: kernel R, user R
<span class="token deleted">-	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span>
<span class="token inserted">+	kern_pgdir[BIG_PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;</span>
 
 	//////////////////////////////////////////////////////////////////////
 	// Allocate an array of npages <span class="token string">'struct PageInfo'</span>s and store it in <span class="token string">'pages'</span>.
@@ -169,8 +175,16 @@ mem_init(void)
 	page_init();
 
 	check_page_free_list(1);
<span class="token deleted">-	check_page_alloc();</span>
<span class="token deleted">-	check_page();</span>
<span class="token inserted">+	// comment this test. because now we still use the manully established</span>
<span class="token inserted">+	// map and check_page_alloc() will alloc and free pages which are 4MB</span>
<span class="token inserted">+	// per page. This will surely casue a page fault and JOS to reboot. in</span>
<span class="token inserted">+	// addition, functions tested by check_page_alloc() are not changed and</span>
<span class="token inserted">+	// have been tested in lab2 branch. so it's OK to comment this test.</span>
<span class="token inserted">+	// check_page_alloc();</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// comment this test. most of this test is related to page table. since</span>
<span class="token inserted">+	// we don't have a page table in big page system, we don't need this test.</span>
<span class="token inserted">+	// check_page();</span>
 
 	//////////////////////////////////////////////////////////////////////
 	// Now we set up virtual memory
@@ -213,8 +227,12 @@ mem_init(void)
 	boot_map_region(kern_pgdir, KERNBASE, 0xFFFFFFFF-KERNBASE, (physaddr_t)0x0, PTE_W);
 
 	// Check that the initial page directory has been set up correctly.
<span class="token deleted">-	check_kern_pgdir();</span>
<span class="token deleted">-</span>
<span class="token inserted">+	// since one big page may cover many important address, it's not suitable</span>
<span class="token inserted">+	// to check our newly established map in check_kern_pgdir() way.</span>
<span class="token inserted">+	// check_kern_pgdir();</span>
<span class="token inserted">+ </span>
<span class="token inserted">+	// enable big page</span>
<span class="token inserted">+	lcr4(rcr4() | CR4_PSE);</span>
 	// Switch from the minimal entry page directory to the full kern_pgdir
 	// page table we just created.	Our instruction pointer should be
 	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
@@ -234,7 +252,9 @@ mem_init(void)
 	lcr0(cr0);
 
 	// Some more checks, only possible after kern_pgdir is installed.
<span class="token deleted">-	check_page_installed_pgdir();</span>
<span class="token inserted">+	// Some of tests in the following function use PGSIZE(4KB) concept,</span>
<span class="token inserted">+	// which is not suitable for big page system.</span>
<span class="token inserted">+	//check_page_installed_pgdir();</span>
 }
 
 // --------------------------------------------------------------
@@ -349,30 +369,21 @@ page_init(void)
 	 * 
 	 */
 
<span class="token inserted">+	// In big page system, it's much easier to initialize PageInfo array</span>
<span class="token inserted">+	// since one page will cover all base memory. Big pages where base</span>
<span class="token inserted">+	// memeory and kernel reside are used and reside contiguously.</span>
 	page_free_list = NULL;
 
<span class="token deleted">-	pages[0].pp_ref = 1;		// mark physical page 0 as in use</span>
<span class="token deleted">-	size_t i;</span>
<span class="token deleted">-	</span>
<span class="token deleted">-	for (i = 1; i &lt; npages_basemem; ++i) {</span>
<span class="token deleted">-		// The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span>
<span class="token deleted">-		// is free.</span>
<span class="token deleted">-		pages[i].pp_ref = 0;</span>
<span class="token deleted">-		pages[i].pp_link = page_free_list;</span>
<span class="token deleted">-		page_free_list = &amp;pages[i];</span>
<span class="token deleted">-	}</span>
<span class="token inserted">+	size_t kernel_end_page = ROUNDUP(((uintptr_t)(boot_alloc(0)) - KERNBASE), BIG_PGSIZE)/BIG_PGSIZE;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	size_t i = 0;</span>
 
<span class="token deleted">-	size_t kernel_end_page = ((uint32_t)(boot_alloc(0)) - KERNBASE)/PGSIZE;</span>
 	for (; i &lt; kernel_end_page; ++i) {
<span class="token deleted">-		// IO hole and kernel physical memory reside consecutively</span>
<span class="token deleted">-		// in physcial memory. So initialize their corresponding </span>
<span class="token deleted">-		// page entries in one loop</span>
 		pages[i].pp_ref = 1;
 		pages[i].pp_link = NULL;
 	}
<span class="token deleted">-	</span>
<span class="token inserted">+</span>
 	for (; i &lt; npages; ++i) {
<span class="token deleted">-		// The rest of extended memory are not used</span>
 		pages[i].pp_ref = 0;
 		pages[i].pp_link = page_free_list;
 		page_free_list = &amp;pages[i];
@@ -467,35 +478,33 @@ page_decref(struct PageInfo* pp)
 // Hint 4: all pointers in C are virtual addresses but all addresses in
 // page dir and page table are physical address
 //
<span class="token deleted">-pte_t *</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * In big page system,</span>
<span class="token inserted">+ * given 'pgdir', a pointer to a page directory, pgdir_walk returns</span>
<span class="token inserted">+ * a pointer to the page directory entry (PDE) for linear address 'va'.</span>
<span class="token inserted">+ * </span>
<span class="token inserted">+ * The relevantt page directory entry might not exist yet.</span>
<span class="token inserted">+ * If this is true, and create == false, then pgdir_walk returns NULL.</span>
<span class="token inserted">+ * Otherwise, pgdir_walk return the corresponding page directory entry.</span>
<span class="token inserted">+ * </span>
<span class="token inserted">+ */</span>
<span class="token inserted">+</span>
<span class="token inserted">+pde_t *</span>
 pgdir_walk(pde_t *pgdir, const void *va, int create)
 {
 	// Fill this function in
<span class="token deleted">-	pde_t *pd_entry = &amp;pgdir[PDX(va)];</span>
<span class="token deleted">-	pte_t *pgtable = NULL;</span>
<span class="token inserted">+	pde_t *pd_entry = &amp;pgdir[BIG_PDX(va)];</span>
 
<span class="token deleted">-	// if the relevant page table page exists</span>
<span class="token deleted">-	if ((physaddr_t)*pd_entry &amp; PTE_P) {</span>
<span class="token deleted">-		pgtable = (pte_t *)(KADDR(PTE_ADDR(*pd_entry)));</span>
<span class="token deleted">-		return &amp;pgtable[PTX(va)];</span>
<span class="token deleted">-	}</span>
<span class="token deleted">-	</span>
<span class="token deleted">-	// if the relevant page table doesn't exist and create == false</span>
<span class="token inserted">+	if ((physaddr_t)*pd_entry &amp; PTE_P)</span>
<span class="token inserted">+		return pd_entry;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// if the relevant page directory entry doesn't exist</span>
<span class="token inserted">+	// and create == false</span>
 	if (create == false)
 		return NULL;
 	
<span class="token deleted">-	// allocate a new page table, use ALLOC_ZERO to clear the page</span>
<span class="token deleted">-	// page_alloc guarantees NULL is returned on allocation failure</span>
<span class="token deleted">-	struct PageInfo *new_page_info = page_alloc(ALLOC_ZERO);</span>
<span class="token deleted">-	if (new_page_info == NULL)</span>
<span class="token deleted">-		return NULL;</span>
<span class="token deleted">-	++(new_page_info->pp_ref);</span>
<span class="token deleted">-	</span>
<span class="token deleted">-	// pages of kernel and users may be allocated on one page table</span>
<span class="token deleted">-	// so it's convenient to give page table a user level privilige</span>
<span class="token deleted">-	*pd_entry = (pde_t)((uintptr_t)page2pa(new_page_info) | PTE_P | PTE_W | PTE_U);</span>
<span class="token deleted">-	pgtable = (pte_t *)page2kva(new_page_info);</span>
<span class="token deleted">-	return &amp;pgtable[PTX(va)];</span>
<span class="token inserted">+	return pd_entry;</span>
 }
 
 //
@@ -512,15 +521,19 @@ pgdir_walk(pde_t *pgdir, const void *va, int create)
 static void
 boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
 {
<span class="token deleted">-	for (size_t alloc_size = 0; alloc_size &lt; size; alloc_size += PGSIZE) {</span>
<span class="token deleted">-		pte_t *pt_entry = pgdir_walk(pgdir, (void *)va, true);</span>
<span class="token inserted">+	uintptr_t round_va = ROUNDDOWN(va, BIG_PGSIZE);</span>
<span class="token inserted">+	uintptr_t round_pa = ROUNDDOWN(pa, BIG_PGSIZE);</span>
<span class="token inserted">+	size_t round_size = ROUNDUP(size + va - round_va, BIG_PGSIZE);</span>
<span class="token inserted">+	for (size_t alloc_size = 0; alloc_size &lt; round_size; alloc_size += BIG_PGSIZE) {</span>
<span class="token inserted">+		pde_t *pd_entry = pgdir_walk(pgdir, (void *)round_va, true);</span>
<span class="token inserted">+</span>
<span class="token inserted">+		if (pd_entry == NULL)</span>
<span class="token inserted">+			panic("Page alloction failed");</span>
 		
<span class="token deleted">-		if (pt_entry == NULL)</span>
<span class="token deleted">-			panic("Page allocation failed!");</span>
<span class="token deleted">-		</span>
<span class="token deleted">-		*pt_entry = pa | perm | PTE_P;</span>
<span class="token deleted">-		va += PGSIZE;</span>
<span class="token deleted">-		pa += PGSIZE;</span>
<span class="token inserted">+		*pd_entry = round_pa | perm | PTE_PS | PTE_P;</span>
<span class="token inserted">+</span>
<span class="token inserted">+		round_va += BIG_PGSIZE;</span>
<span class="token inserted">+		round_pa += BIG_PGSIZE;</span>
 	}
 }
 
@@ -556,20 +569,22 @@ boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm
 // Hint: The TA solution is implemented using pgdir_walk, page_remove,
 // and page2pa.
 //
<span class="token inserted">+</span>
 int
 page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 {
 	// Fill this function in
<span class="token deleted">-	pte_t *pt_entry = pgdir_walk(pgdir, va, true);</span>
<span class="token deleted">-	</span>
<span class="token deleted">-	if (pt_entry == NULL)</span>
<span class="token inserted">+	pde_t *pd_entry = pgdir_walk(pgdir, va, true);</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (pd_entry == NULL)</span>
 		return -E_NO_MEM;
 
 	++(pp->pp_ref);
<span class="token deleted">-	if (*pt_entry &amp; PTE_P)</span>
<span class="token deleted">-		page_remove(pgdir, va);		// page_remove() will call tlb_invalidate()</span>
<span class="token inserted">+	if (*pd_entry &amp; PTE_P)</span>
<span class="token inserted">+		page_remove(pgdir, va);</span>
 
<span class="token deleted">-	*pt_entry = page2pa(pp) | perm | PTE_P;</span>
<span class="token inserted">+	*pd_entry = page2pa(pp) | perm | PTE_P;</span>
<span class="token inserted">+	</span>
 	return 0;
 }
 
@@ -584,20 +599,19 @@ page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
 //
 // Hint: the TA solution uses pgdir_walk and pa2page.
 //
<span class="token inserted">+</span>
 struct PageInfo *
<span class="token deleted">-page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)</span>
<span class="token inserted">+page_lookup(pde_t *pgdir, void *va, pde_t **pde_store)</span>
 {
<span class="token deleted">-	// Fill this function in</span>
<span class="token deleted">-</span>
<span class="token deleted">-	pte_t *pt_entry = pgdir_walk(pgdir, va, false);</span>
<span class="token inserted">+	pde_t *pd_entry = pgdir_walk(pgdir, va, false);</span>
 
<span class="token deleted">-	if (pt_entry == NULL)</span>
<span class="token inserted">+	if (pd_entry == NULL)</span>
 		return NULL;
 	
<span class="token deleted">-	if (pte_store)	// if pte_store is not zero</span>
<span class="token deleted">-		*pte_store = pt_entry;</span>
<span class="token deleted">-</span>
<span class="token deleted">-	return pa2page(PTE_ADDR(*pt_entry));</span>
<span class="token inserted">+	if (pde_store)</span>
<span class="token inserted">+		*pde_store = pd_entry;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	return pa2page(PDE_ADDR(*pd_entry));</span>
 }
 
 //
@@ -615,17 +629,17 @@ page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
 // Hint: The TA solution is implemented using page_lookup,
 // 	tlb_invalidate, and page_decref.
 //
<span class="token inserted">+</span>
 void
 page_remove(pde_t *pgdir, void *va)
 {
<span class="token deleted">-	// Fill this function in</span>
<span class="token deleted">-	pte_t *pt_entry;</span>
<span class="token deleted">-	struct PageInfo *mapped_page = page_lookup(pgdir, va, &amp;pt_entry);</span>
<span class="token deleted">-	if (mapped_page == NULL)	// no physical page mapped, do nothing</span>
<span class="token inserted">+	pde_t *pd_entry;</span>
<span class="token inserted">+	struct PageInfo *mapped_page = page_lookup(pgdir, va, &amp;pd_entry);</span>
<span class="token inserted">+	if (mapped_page == NULL)</span>
 		return;
 	
 	page_decref(mapped_page);
<span class="token deleted">-	*pt_entry = 0;</span>
<span class="token inserted">+	*pd_entry = 0;</span>
 	tlb_invalidate(pgdir, va);
 }
 
@@ -701,7 +715,10 @@ check_page_free_list(bool only_low_memory)
 			++nfree_extmem;
 	}
 
<span class="token deleted">-	assert(nfree_basemem > 0);</span>
<span class="token inserted">+	// comment this assert as the first 4MB page already cover base memory.</span>
<span class="token inserted">+	// furthermore, some of base memory is used. So no page in base memory</span>
<span class="token inserted">+	// is free.</span>
<span class="token inserted">+	//assert(nfree_basemem > 0);</span>
 	assert(nfree_extmem > 0);
 
 	cprintf(<span class="token string">"check_page_free_list() succeeded!\n"</span>);
@@ -736,10 +753,10 @@ check_page_alloc(void)
 	assert(pp0);
 	assert(pp1 &amp;&amp; pp1 != pp0);
 	assert(pp2 &amp;&amp; pp2 != pp1 &amp;&amp; pp2 != pp0);
<span class="token deleted">-	assert(page2pa(pp0) &lt; npages*PGSIZE);</span>
<span class="token deleted">-	assert(page2pa(pp1) &lt; npages*PGSIZE);</span>
<span class="token deleted">-	assert(page2pa(pp2) &lt; npages*PGSIZE);</span>
<span class="token deleted">-</span>
<span class="token inserted">+	assert(page2pa(pp0) &lt; npages*BIG_PGSIZE);</span>
<span class="token inserted">+	assert(page2pa(pp1) &lt; npages*BIG_PGSIZE);</span>
<span class="token inserted">+	assert(page2pa(pp2) &lt; npages*BIG_PGSIZE);</span>
<span class="token inserted">+	</span>
 	// temporarily steal the rest of the free pages
 	fl = page_free_list;
 	page_free_list = 0;
@@ -761,7 +778,7 @@ check_page_alloc(void)
 	assert(!page_alloc(0));
 
 	// test flags
<span class="token deleted">-	memset(page2kva(pp0), 1, PGSIZE);</span>
<span class="token inserted">+	memset(page2kva(pp0), 1, BIG_PGSIZE);</span>
 	page_free(pp0);
 	assert((pp = page_alloc(ALLOC_ZERO)));
 	assert(pp &amp;&amp; pp0 == pp);
@@ -771,7 +788,7 @@ check_page_alloc(void)
 
 	// give free list back
 	page_free_list = fl;
<span class="token deleted">-</span>
<span class="token inserted">+	</span>
 	// free the pages we took
 	page_free(pp0);
 	page_free(pp1);
@@ -888,7 +905,9 @@ check_page(void)
 	assert(page_lookup(kern_pgdir, (void *) 0x0, &amp;ptep) == NULL);
 
 	// there is no free memory, so we can't allocate a page table
<span class="token deleted">-	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) &lt; 0);</span>
<span class="token inserted">+	// in big page system, there is no page table. so this test is</span>
<span class="token inserted">+	// unnecessary.</span>
<span class="token inserted">+	// assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) &lt; 0);</span>
 
 	// free pp0 and try again: pp0 should be used for page table
 	page_free(pp0);
diff --git a/kern/pmap.h b/kern/pmap.h
index 9d447fc..754c443 100644
<span class="token deleted">--- a/kern/pmap.h</span>
<span class="token inserted">+++ b/kern/pmap.h</span>
<span class="token coord">@@ -9,7 +9,8 @@</span>
 #include &lt;inc/memlayout.h>
 #include &lt;inc/assert.h>
 
<span class="token deleted">-#define npages_in_4GB	(1&lt;&lt;(32-PGSHIFT))</span>
<span class="token inserted">+#define npages_in_4GB	(1 &lt;&lt; (32 - BIG_PGSHIFT))</span>
<span class="token inserted">+//#define npages_in_4GB	(1&lt;&lt;(32-PGSHIFT))</span>
 #define DWORD_SIZE		4		// four bytes per dword
 #define DOWRD_SHIFT		2		// log2(DWORD_SIZE)
 #define ndwords_in_4GB	(1&lt;&lt;(32-DOWRD_SHIFT))
@@ -45,7 +46,7 @@ _paddr(const char *file, int line, void *kva)
 static inline void*
 _kaddr(const char *file, int line, physaddr_t pa)
 {
<span class="token deleted">-	if (PGNUM(pa) >= npages)</span>
<span class="token inserted">+	if (BIG_PGNUM(pa) >= npages)</span>
 		_panic(file, line, <span class="token string">"KADDR called with invalid pa %08lx"</span>, pa);
 	return (void *)(pa + KERNBASE);
 }
@@ -71,15 +72,15 @@ void	tlb_invalidate(pde_t *pgdir, void *va);
 static inline physaddr_t
 page2pa(struct PageInfo *pp)
 {
<span class="token deleted">-	return (pp - pages) &lt;&lt; PGSHIFT;</span>
<span class="token inserted">+	return (pp - pages) &lt;&lt; BIG_PGSHIFT;</span>
 }
 
 static inline struct PageInfo*
 pa2page(physaddr_t pa)
 {
<span class="token deleted">-	if (PGNUM(pa) >= npages)</span>
<span class="token inserted">+	if (BIG_PGNUM(pa) >= npages)</span>
 		panic(<span class="token string">"pa2page called with invalid pa"</span>);
<span class="token deleted">-	return &amp;pages[PGNUM(pa)];</span>
<span class="token inserted">+	return &amp;pages[BIG_PGNUM(pa)];</span>
 }
 
 static inline void*
</pre><h3 class="mume-header" id="challenge-2" ebook-toc-level-3="" heading="Challenge 2">Challenge 2</h3>

<blockquote>
<p>Extend the JOS kernel monitor with commands to:</p>
<ul>
<li>Display in a useful and easy-to-read format all of the physical page mappings (or lack thereof) that apply to a particular range of virtual/linear addresses in the currently active address space. For example, you might enter ‘showmappings 0x3000 0x5000’ to display the physical page mappings and corresponding permission bits that apply to the pages at virtual addresses 0x3000, 0x4000, and 0x5000.</li>
<li>Explicitly set, clear, or change the permissions of any mapping in the current address space.</li>
<li>Dump the contents of a range of memory given either a virtual or physical address range. Be sure the dump code behaves correctly when the range extends across page boundaries!</li>
</ul>
</blockquote>
<p>As long as you understand what we have talked about in this report, it’s easy to implemente functions required.</p>
<p>The following is a exhibition of fuctions I implemented in this challenge.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">***
*** Use Ctrl-a x to <span class="token keyword">exit</span> qemu
***
qemu-system-i386 -nographic -drive file<span class="token operator">=</span>obj/kern/kernel.img,index<span class="token operator">=</span>0,media<span class="token operator">=</span>disk,format<span class="token operator">=</span>raw -serial mon:stdio -gdb tcp::26000 -D qemu.log 
6828 decimal is 15254 octal<span class="token operator">!</span>
Physical memory: 131072K available, base <span class="token operator">=</span> 640K, extended <span class="token operator">=</span> 130432K
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_alloc<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_kern_pgdir<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_installed_pgdir<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
Welcome to the JOS kernel monitor<span class="token operator">!</span>
Type <span class="token string">'help'</span> <span class="token keyword">for</span> a list of commands.
K<span class="token operator">></span> <span class="token function">help</span> list
<span class="token function">help</span>
-SYNOPSIS:
    <span class="token function">help</span> <span class="token punctuation">{</span>list <span class="token operator">|</span> <span class="token function">command</span> name<span class="token punctuation">}</span>
-DESCRIPTION:
    list: display all <span class="token function">help</span> information of all commands.
    <span class="token function">command</span> name: display <span class="token function">help</span> information of given name

kerninfo
Display information about the kernel

backtrace
Display the current call stack

mappings
-SYNOPSIS:
    mappings <span class="token punctuation">{</span>show laddr uaddr<span class="token punctuation">}</span> <span class="token operator">|</span> <span class="token punctuation">{</span>clear vaddr <span class="token punctuation">[</span>size<span class="token operator">==</span>1<span class="token punctuation">]</span><span class="token punctuation">}</span>
             <span class="token operator">|</span> <span class="token punctuation">{</span>set perm vaddr <span class="token punctuation">[</span>size<span class="token operator">==</span>1<span class="token punctuation">]</span><span class="token punctuation">}</span>
-DESCRIPTION:
    show: display page mappings <span class="token keyword">in</span> <span class="token punctuation">[</span>laddr, uaddr<span class="token punctuation">)</span>
    clear: <span class="token function">clear</span> privilege of size<span class="token punctuation">(</span>in page<span class="token punctuation">)</span> pages from vaddr.
           The privilege is <span class="token keyword">set</span> to PTE_U <span class="token operator">==</span> 0 and PTE_W <span class="token operator">==</span> 1.
    set: <span class="token keyword">set</span> privilege of size<span class="token punctuation">(</span>in page<span class="token punctuation">)</span> pages from vaddr.
         The privilege <span class="token string">'perm'</span> can be specified by a number or a
         two-character string containing <span class="token string">'u'</span><span class="token punctuation">(</span>PTE_U<span class="token punctuation">)</span>, <span class="token string">'w'</span><span class="token punctuation">(</span>PTE_W<span class="token punctuation">)</span> or
         <span class="token string">'-'</span><span class="token punctuation">(</span>none<span class="token punctuation">)</span>
    All addresses will be rounded down to page alignment.

dump
-SYNOPSIS:
    dump addr_type addr <span class="token punctuation">[</span>size<span class="token operator">==</span>1<span class="token punctuation">]</span>
-DESCRIPTION:
    addr_type: <span class="token string">'-v'</span> <span class="token keyword">for</span> virtual address, <span class="token string">'-p for physical address
    addr: beginning address
    size: memory size in dwords(4 bytes)

K> mappings show 0xf0100000 0xf0104000
         vaddr                       paddr            privilege
0xf0100000 - 0xf0101000:    0x00100000 - 0x00101000      -w
0xf0101000 - 0xf0102000:    0x00101000 - 0x00102000      -w
0xf0102000 - 0xf0103000:    0x00102000 - 0x00103000      -w
0xf0103000 - 0xf0104000:    0x00103000 - 0x00104000      -w
K> mappings set uw 0xf0100000 4
K> mappings show 0xf0100000 0xf0104000
         vaddr                       paddr            privilege
0xf0100000 - 0xf0101000:    0x00100000 - 0x00101000      uw
0xf0101000 - 0xf0102000:    0x00101000 - 0x00102000      uw
0xf0102000 - 0xf0103000:    0x00102000 - 0x00103000      uw
0xf0103000 - 0xf0104000:    0x00103000 - 0x00104000      uw
K> mappings clear 0xf0100000 4
K> mappings show 0xf0100000 0xf0104000
         vaddr                       paddr            privilege
0xf0100000 - 0xf0101000:    0x00100000 - 0x00101000      -w
0xf0101000 - 0xf0102000:    0x00101000 - 0x00102000      -w
0xf0102000 - 0xf0103000:    0x00102000 - 0x00103000      -w
0xf0103000 - 0xf0104000:    0x00103000 - 0x00104000      -w
K> dump -v 0xf0100000 10
0xf0100000:  0x1badb002  0x00000000  0xe4524ffe  0x7205c766  
0xf0100010:  0x34000004  0x7000b812  0x220f0011  0xc0200fd8  
0xf0100020:  0x0100010d  0xc0220f80  
K> dump -p 0x00100000 10
0x100000:  0x1badb002  0x00000000  0xe4524ffe  0x7205c766  
0x100010:  0x34000004  0x7000b812  0x220f0011  0xc0200fd8  
0x100020:  0x0100010d  0xc0220f80  
K> QEMU 2.5.0 monitor - type '</span>help' <span class="token keyword">for</span> <span class="token function">more</span> information
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> x/10x 0xf0100000
f0100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766
f0100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8
f0100020: 0x0100010d 0xc0220f80
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> xp/10x 0x00100000
0000000000100000: 0x1badb002 0x00000000 0xe4524ffe 0x7205c766
0000000000100010: 0x34000004 0x7000b812 0x220f0011 0xc0200fd8
0000000000100020: 0x0100010d 0xc0220f80
<span class="token punctuation">(</span>qemu<span class="token punctuation">)</span> QEMU: Terminated
</pre><p>The code for implementing these functions is shown in the following <code>git diff</code> log.</p>
<pre data-role="codeBlock" data-info="git" class="language-git">diff --git a/kern/monitor.c b/kern/monitor.c
index f77abb7..67ddd15 100644
<span class="token deleted">--- a/kern/monitor.c</span>
<span class="token inserted">+++ b/kern/monitor.c</span>
<span class="token coord">@@ -7,10 +7,12 @@</span>
 #include &lt;inc/assert.h>
 #include &lt;inc/x86.h>
 #include &lt;inc/color.h>
<span class="token inserted">+#include &lt;inc/types.h></span>
 
 #include &lt;kern/console.h>
 #include &lt;kern/monitor.h>
 #include &lt;kern/kdebug.h>
<span class="token inserted">+#include &lt;kern/pmap.h></span>
 
 #define CMDBUF_SIZE	80	// enough for one VGA text line
 
@@ -23,20 +25,90 @@ struct Command {
 };
 
 static struct Command commands[] = {
<span class="token deleted">-	{ "help", "Display this list of commands", mon_help },</span>
<span class="token deleted">-	{ "kerninfo", "Display information about the kernel", mon_kerninfo },</span>
<span class="token deleted">-	{ "backtrace", "Display the current call stack", mon_backtrace},</span>
<span class="token inserted">+	{ "help", CMD_HELP_HELP_STR, mon_help },</span>
<span class="token inserted">+	{ "kerninfo", CMD_KERNINFO_HELP_STR, mon_kerninfo },</span>
<span class="token inserted">+	{ "backtrace", CMD_BACKTRACE_HELP_STR, mon_backtrace},</span>
<span class="token inserted">+	{ "mappings", CMD_MAPPINGS_HELP_STR, mon_mappings},</span>
<span class="token inserted">+	{ "dump", CMD_DUMP_HELP_STR, mon_dump},</span>
 };
 
<span class="token inserted">+/***** helper functions *****/</span>
<span class="token inserted">+#define ADDR_TYPE_V		0		// virtual address type</span>
<span class="token inserted">+#define ADDR_TYPE_P		1		// physical address type</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define CMD_ERR_ARG		0		// wrong arguments</span>
<span class="token inserted">+#define CMD_ERR_NUM		1		// invalid number format</span>
<span class="token inserted">+#define CMD_ERR_OPE		2		// invalid operation</span>
<span class="token inserted">+#define CMD_ERR_STR		3		// not specific error</span>
<span class="token inserted">+</span>
<span class="token inserted">+inline int</span>
<span class="token inserted">+cmd_error(int err_type, char *str)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	switch(err_type) {</span>
<span class="token inserted">+		case CMD_ERR_ARG: </span>
<span class="token inserted">+			cprintf("E: Wrong arguments! type 'help %s' for usage.\n", str);</span>
<span class="token inserted">+			break;</span>
<span class="token inserted">+		case CMD_ERR_NUM:</span>
<span class="token inserted">+			cprintf("E: Wrong Number format!\n");</span>
<span class="token inserted">+			break;</span>
<span class="token inserted">+		case CMD_ERR_OPE:</span>
<span class="token inserted">+			cprintf("E: Invalid operation %s\n", str);</span>
<span class="token inserted">+			break;</span>
<span class="token inserted">+		case CMD_ERR_STR:</span>
<span class="token inserted">+			cprintf("E: %s\n", str);</span>
<span class="token inserted">+			break;</span>
<span class="token inserted">+		default:</span>
<span class="token inserted">+			cprintf("E: Wrong error type!\n");</span>
<span class="token inserted">+			break;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	return 0;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+// using macro to mimic a template function to adapt</span>
<span class="token inserted">+// different types of _num_ptr</span>
<span class="token inserted">+#define parse_number(_num_str, _num_ptr)			\</span>
<span class="token inserted">+({													\</span>
<span class="token inserted">+	typeof(_num_str) __num_str = (_num_str);		\</span>
<span class="token inserted">+	typeof(_num_ptr) __num_ptr = (_num_ptr);	\</span>
<span class="token inserted">+	char *end_char;									\</span>
<span class="token inserted">+	*__num_ptr = strtol(__num_str, &amp;end_char, 0);	\</span>
<span class="token inserted">+	*end_char != '\0';								\</span>
<span class="token inserted">+})</span>
<span class="token inserted">+</span>
<span class="token inserted">+</span>
 /***** Implementations of basic kernel monitor commands *****/
 
 int
 mon_help(int argc, char **argv, struct Trapframe *tf)
 {
<span class="token deleted">-	int i;</span>
<span class="token inserted">+	char *operation;</span>
<span class="token inserted">+	if ((operation = argv[1]) == 0) {</span>
<span class="token inserted">+		cprintf(CMD_HELP_HELP_STR);</span>
<span class="token inserted">+		return 0;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (argc > 2)</span>
<span class="token inserted">+		return cmd_error(CMD_ERR_ARG, "help");</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (strcmp(operation, "list") == 0) {</span>
<span class="token inserted">+		for (int i = 0; i &lt; ARRAY_SIZE(commands); i++)</span>
<span class="token inserted">+			cprintf("%s\n%s\n", commands[i].name, commands[i].desc);</span>
<span class="token inserted">+		return 0;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+</span>
<span class="token inserted">+	bool cmd_found = false;</span>
<span class="token inserted">+	for (int i = 0; i &lt; ARRAY_SIZE(commands); i++) {</span>
<span class="token inserted">+		if (strcmp(operation, commands[i].name) == 0) {</span>
<span class="token inserted">+			cprintf("%s\n%s\n", commands[i].name, commands[i].desc);</span>
<span class="token inserted">+			cmd_found = true;</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (!cmd_found)</span>
<span class="token inserted">+		cprintf("command not found!\n");</span>
 
<span class="token deleted">-	for (i = 0; i &lt; ARRAY_SIZE(commands); i++)</span>
<span class="token deleted">-		cprintf("%s - %s\n", commands[i].name, commands[i].desc);</span>
 	return 0;
 }
 
@@ -103,7 +175,283 @@ mon_backtrace(int argc, char **argv, struct Trapframe *tf)
 	return 0;
 }
 
<span class="token inserted">+int</span>
<span class="token inserted">+show_mappings(uintptr_t lower_addr, uintptr_t upper_addr)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	uintptr_t laddr = ROUNDDOWN(lower_addr, PGSIZE);</span>
<span class="token inserted">+	uintptr_t uaddr = ROUNDDOWN(upper_addr, PGSIZE);</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (laddr != lower_addr)</span>
<span class="token inserted">+		cprintf("lower address:%p -> %p\n", lower_addr, laddr);</span>
<span class="token inserted">+	if (uaddr != upper_addr)</span>
<span class="token inserted">+		cprintf("upper address:%p -> %p\n", upper_addr, uaddr);</span>
<span class="token inserted">+</span>
<span class="token inserted">+	cprintf("         vaddr                       paddr            privilege\n");</span>
<span class="token inserted">+	while (laddr &lt; uaddr) {</span>
<span class="token inserted">+		cprintf("%08p - %08p:    ", laddr, laddr + PGSIZE);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		pte_t *pt_entry = pgdir_walk(kern_pgdir, (void *)laddr, false);</span>
<span class="token inserted">+		if (pt_entry == NULL || !(*pt_entry &amp; PTE_P)) {</span>
<span class="token inserted">+			cprintf("not mapped\n");</span>
<span class="token inserted">+		} else {</span>
<span class="token inserted">+			physaddr_t pte_paddr = PTE_ADDR(*pt_entry);</span>
<span class="token inserted">+			char privilege[] = {</span>
<span class="token inserted">+				(*pt_entry &amp; PTE_U) ? 'u' : '-',</span>
<span class="token inserted">+				(*pt_entry &amp; PTE_W) ? 'w' : '-',</span>
<span class="token inserted">+				'\0'</span>
<span class="token inserted">+			};</span>
<span class="token inserted">+</span>
<span class="token inserted">+			cprintf("%08p - %08p      %s\n", pte_paddr, pte_paddr + PGSIZE, privilege);</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+</span>
<span class="token inserted">+		laddr += PGSIZE;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	return 0;	</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+int</span>
<span class="token inserted">+set_mappings(uintptr_t virtual_addr, size_t size, int perm)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	if (PGNUM(virtual_addr) + size > npages_in_4GB)</span>
<span class="token inserted">+		return cmd_error(CMD_ERR_STR, "Addresses exceed 4G memory!");</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	uintptr_t vaddr = ROUNDDOWN(virtual_addr, PGSIZE);</span>
<span class="token inserted">+	if (vaddr != virtual_addr)</span>
<span class="token inserted">+		cprintf("virtual address:%p -> %p\n", virtual_addr, vaddr);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	while (size-- > 0) {</span>
<span class="token inserted">+		pte_t *pte_ptr = pgdir_walk(kern_pgdir, (void *)vaddr, false);</span>
<span class="token inserted">+		pte_t pt_entry = *pte_ptr;</span>
<span class="token inserted">+		if (pt_entry &amp; PTE_P) {</span>
<span class="token inserted">+			// turn off PTE_U and PTE_W</span>
<span class="token inserted">+			pt_entry &amp;= ~(PTE_U | PTE_W);</span>
<span class="token inserted">+			</span>
<span class="token inserted">+			// mask off other bits in perm, and turn on bits</span>
<span class="token inserted">+			// in *pt_entry based on perm</span>
<span class="token inserted">+			pt_entry |= (perm &amp; (PTE_U | PTE_W));</span>
<span class="token inserted">+			*pte_ptr = pt_entry;</span>
<span class="token inserted">+		} else</span>
<span class="token inserted">+			cprintf("W: %d not mapped!\n", vaddr);</span>
<span class="token inserted">+</span>
<span class="token inserted">+		vaddr += PGSIZE;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	return 0;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+int</span>
<span class="token inserted">+clear_mappings(uintptr_t virtual_addr, size_t size)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	// turn off PTE_U</span>
<span class="token inserted">+	return set_mappings(virtual_addr, size, PTE_W);</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+int</span>
<span class="token inserted">+mon_mappings(int argc, char **argv, struct Trapframe *tf)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	/*</span>
<span class="token inserted">+	 * SYNOPSIS:</span>
<span class="token inserted">+	 * 		mappings {show laddr uaddr} |</span>
<span class="token inserted">+	 * 				 {clear vaddr [size]} |</span>
<span class="token inserted">+	 * 				 {set perm vaddr [size]}</span>
<span class="token inserted">+	 * 		laddr: lower address</span>
<span class="token inserted">+	 * 		uaddr: upper address</span>
<span class="token inserted">+	 * 		vaddr: virtual address</span>
<span class="token inserted">+	 * 		paddr: physical address</span>
<span class="token inserted">+	 * 		size: memory size in pages</span>
<span class="token inserted">+	 * 		perm: page table entry permission</span>
<span class="token inserted">+	 */</span>
<span class="token inserted">+</span>
<span class="token inserted">+	char *operation;</span>
<span class="token inserted">+	if ((operation = argv[1]) == 0) {</span>
<span class="token inserted">+		cprintf(CMD_MAPPINGS_HELP_STR);</span>
<span class="token inserted">+		return 0;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (strcmp(operation, "show") == 0) {</span>
<span class="token inserted">+		// mappings {show laddr uaddr}</span>
<span class="token inserted">+</span>
<span class="token inserted">+		if (argc != 4)</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_ARG, "mappings");</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		uintptr_t laddr, uaddr;</span>
<span class="token inserted">+		if (parse_number(argv[2], &amp;laddr) ||</span>
<span class="token inserted">+			parse_number(argv[3], &amp;uaddr))</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_NUM,"");</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		return show_mappings(laddr, uaddr);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (strcmp(operation, "clear") == 0) {</span>
<span class="token inserted">+		// mappings {clear vaddr [size]}</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		if (argc &lt; 3 || argc > 4)</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_ARG, "mappings");</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		uintptr_t vaddr;</span>
<span class="token inserted">+		if (parse_number(argv[2], &amp;vaddr))</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_NUM, NULL);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		size_t size;</span>
<span class="token inserted">+		if (argv[3]) {		// if size is provided explicitly</span>
<span class="token inserted">+			if (parse_number(argv[3], &amp;size))</span>
<span class="token inserted">+				return cmd_error(CMD_ERR_NUM, NULL);</span>
<span class="token inserted">+		} else</span>
<span class="token inserted">+			size = 1;</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		return clear_mappings(vaddr, size);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (strcmp(operation, "set") == 0) {</span>
<span class="token inserted">+		// mappings {set perm vaddr [size]}</span>
<span class="token inserted">+		if (argc &lt; 4 || argc > 5)</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_ARG, "mappings");</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		int perm;</span>
<span class="token inserted">+		char *perm_str = argv[2];</span>
<span class="token inserted">+		if (parse_number(perm_str, &amp;perm)) {</span>
<span class="token inserted">+			if (strlen(perm_str) != 2)</span>
<span class="token inserted">+				return cmd_error(CMD_ERR_STR, "Wrong privilege format!");</span>
<span class="token inserted">+			</span>
<span class="token inserted">+			perm = 0;</span>
<span class="token inserted">+			for (int i = 0; i &lt; 2; ++i) {</span>
<span class="token inserted">+				if (perm_str[i] == 'u')</span>
<span class="token inserted">+					perm |= PTE_U;</span>
<span class="token inserted">+				else if (perm_str[i] == 'w')</span>
<span class="token inserted">+					perm |= PTE_W;</span>
<span class="token inserted">+				else if (perm_str[i] == '-')</span>
<span class="token inserted">+					continue;</span>
<span class="token inserted">+				else</span>
<span class="token inserted">+					return cmd_error(CMD_ERR_STR, "Wrong privilege format!");</span>
<span class="token inserted">+			}</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+</span>
<span class="token inserted">+		uintptr_t vaddr;</span>
<span class="token inserted">+		if (parse_number(argv[3], &amp;vaddr))</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_NUM, NULL);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		size_t size;</span>
<span class="token inserted">+		if (argv[4]) {		// if size is provided explicitly</span>
<span class="token inserted">+			if (parse_number(argv[4], &amp;size))</span>
<span class="token inserted">+				return cmd_error(CMD_ERR_NUM, NULL);</span>
<span class="token inserted">+		} else</span>
<span class="token inserted">+			size = 1;</span>
<span class="token inserted">+</span>
<span class="token inserted">+		return set_mappings(vaddr, size, perm);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	return cmd_error(CMD_ERR_OPE, operation);</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+int</span>
<span class="token inserted">+dump_vmem(uintptr_t addr, size_t size)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	// dump memory using virtual address</span>
<span class="token inserted">+	// DWORD alignment</span>
<span class="token inserted">+	addr = ROUNDDOWN(addr, 4);</span>
<span class="token inserted">+	if (DOWRD_NUM(addr) + size > ndwords_in_4GB)</span>
<span class="token inserted">+		return cmd_error(CMD_ERR_STR, "Addresses exceed 4G memory!");</span>
<span class="token inserted">+</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	while(size > 0) {</span>
<span class="token inserted">+		cprintf("%p:  ", addr);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		// display four dwords each line</span>
<span class="token inserted">+		for (int i = 0; i &lt; 4 &amp;&amp; size > 0; ++i) {</span>
<span class="token inserted">+			// we don't want to cause a page fault if addr points to a</span>
<span class="token inserted">+			// page that has not been mapped. So we check whether the</span>
<span class="token inserted">+			// page pointed has been mapped.</span>
<span class="token inserted">+			// In fact, as long as consecutive addrs reside in the same</span>
<span class="token inserted">+			// page, we don't need to call page_lookup() repeatedly. We</span>
<span class="token inserted">+			// will improve it later.</span>
<span class="token inserted">+			if (page_lookup(kern_pgdir, (void *)addr, NULL))</span>
<span class="token inserted">+				cprintf("0x%08x  ", *((uint32_t *)addr));</span>
<span class="token inserted">+			else</span>
<span class="token inserted">+				cprintf("not mapped  ");</span>
<span class="token inserted">+			</span>
<span class="token inserted">+			--size;</span>
<span class="token inserted">+			addr += DWORD_SIZE;</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+</span>
<span class="token inserted">+		cprintf("\n");</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	return 0;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+int</span>
<span class="token inserted">+dump_pmem(physaddr_t addr, size_t size) {</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	while(size > 0) {</span>
<span class="token inserted">+		cprintf("%p:  ", addr);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		// display four dwords each line</span>
<span class="token inserted">+		for (int i = 0; i &lt; 4 &amp;&amp; size > 0; ++i) {</span>
<span class="token inserted">+			if (PGNUM(addr) >= npages) {</span>
<span class="token inserted">+				// pa2page() will panic JOS if addr is a invalid physical</span>
<span class="token inserted">+				// address. We don't want a normal shell command that</span>
<span class="token inserted">+				// doesn't have any side effect to panic our JOS. So we</span>
<span class="token inserted">+				// check the legitimacy of addr in advance. The same check</span>
<span class="token inserted">+				// is executed in pg2page() as well as page2kva() but we</span>
<span class="token inserted">+				// don't want those condition check branch into a panic().</span>
<span class="token inserted">+				cprintf("\nExceed physical memory!");</span>
<span class="token inserted">+				size = 0; // break outer while loop, too.</span>
<span class="token inserted">+				break;</span>
<span class="token inserted">+			}</span>
<span class="token inserted">+</span>
<span class="token inserted">+			// A physical address will always be transformed into a linear</span>
<span class="token inserted">+			// address above KERNBASE, where we has mapped that linear</span>
<span class="token inserted">+			// address space in mem_init(). So we needn't worry *num_ptr</span>
<span class="token inserted">+			// will cause a page fault.</span>
<span class="token inserted">+			uint32_t *num_ptr = page2kva(pa2page(addr)) + PGOFF(addr);</span>
<span class="token inserted">+			cprintf("0x%08x  ", *num_ptr);</span>
<span class="token inserted">+</span>
<span class="token inserted">+			--size;</span>
<span class="token inserted">+			addr += DWORD_SIZE;</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+</span>
<span class="token inserted">+		cprintf("\n");</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	return 0;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+int</span>
<span class="token inserted">+mon_dump(int argc, char **argv, struct Trapframe *tf) {</span>
<span class="token inserted">+	/*</span>
<span class="token inserted">+	 * dump addr_type addr [size==1]</span>
<span class="token inserted">+	 *     addr_type: address type, -p | -v</span>
<span class="token inserted">+	 *     addr: beginning address</span>
<span class="token inserted">+	 *     size: memory size in DWORD(32 bits)</span>
<span class="token inserted">+	 */</span>
 
<span class="token inserted">+	char *addr_type_str;</span>
<span class="token inserted">+	if ((addr_type_str = argv[1]) == 0) {</span>
<span class="token inserted">+		cprintf(CMD_DUMP_HELP_STR);</span>
<span class="token inserted">+		return 0;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (argc &lt; 3 || argc > 4)</span>
<span class="token inserted">+		return cmd_error(CMD_ERR_ARG, "dump");</span>
<span class="token inserted">+</span>
<span class="token inserted">+</span>
<span class="token inserted">+	uint32_t addr ;</span>
<span class="token inserted">+	if (parse_number(argv[2], &amp;addr))</span>
<span class="token inserted">+		return cmd_error(CMD_ERR_NUM, NULL);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	size_t size;</span>
<span class="token inserted">+	if (argc == 4) {</span>
<span class="token inserted">+		if (parse_number(argv[3], &amp;size))</span>
<span class="token inserted">+			return cmd_error(CMD_ERR_NUM, NULL);</span>
<span class="token inserted">+	} else</span>
<span class="token inserted">+		size = 1;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (strcmp(addr_type_str, "-v") == 0)</span>
<span class="token inserted">+		return dump_vmem((uintptr_t)addr, size);</span>
<span class="token inserted">+	else if (strcmp(addr_type_str, "-p") == 0)</span>
<span class="token inserted">+		return dump_pmem((physaddr_t)addr, size);</span>
<span class="token inserted">+	else</span>
<span class="token inserted">+		return cmd_error(CMD_ERR_STR, "Wrong address type!");</span>
<span class="token inserted">+}</span>
 
 /***** Kernel monitor command interpreter *****/
 
diff --git a/kern/monitor.h b/kern/monitor.h
index 0aa0f26..33d53a2 100644
<span class="token deleted">--- a/kern/monitor.h</span>
<span class="token inserted">+++ b/kern/monitor.h</span>
@@ -15,5 +15,40 @@ void monitor(struct Trapframe *tf);
 int mon_help(int argc, char **argv, struct Trapframe *tf);
 int mon_kerninfo(int argc, char **argv, struct Trapframe *tf);
 int mon_backtrace(int argc, char **argv, struct Trapframe *tf);
<span class="token inserted">+int mon_mappings(int argc, char **argv, struct Trapframe *tf);</span>
<span class="token inserted">+int mon_dump(int argc, char **argv, struct Trapframe *tf);</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define CMD_HELP_HELP_STR       "\</span>
<span class="token inserted">+-SYNOPSIS:\n\</span>
<span class="token inserted">+    help {list | command name}\n\</span>
<span class="token inserted">+-DESCRIPTION:\n\</span>
<span class="token inserted">+    list: display all help information of all commands.\n\</span>
<span class="token inserted">+    command name: display help information of given name\n"</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define CMD_KERNINFO_HELP_STR   "Display information about the kernel\n"</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define CMD_BACKTRACE_HELP_STR  "Display the current call stack\n"</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define CMD_MAPPINGS_HELP_STR   "\</span>
<span class="token inserted">+-SYNOPSIS:\n\</span>
<span class="token inserted">+    mappings {show laddr uaddr} | {clear vaddr [size==1]}\n\</span>
<span class="token inserted">+             | {set perm vaddr [size==1]}\n\</span>
<span class="token inserted">+-DESCRIPTION:\n\</span>
<span class="token inserted">+    show: display page mappings in [laddr, uaddr)\n\</span>
<span class="token inserted">+    clear: clear privilege of size(in page) pages from vaddr.\n\</span>
<span class="token inserted">+           The privilege is set to PTE_U == 0 and PTE_W == 1.\n\</span>
<span class="token inserted">+    set: set privilege of size(in page) pages from vaddr.\n\</span>
<span class="token inserted">+         The privilege 'perm' can be specified by a number or a\n\</span>
<span class="token inserted">+         two-character string containing 'u'(PTE_U), 'w'(PTE_W) or\n\</span>
<span class="token inserted">+         '-'(none)\n\</span>
<span class="token inserted">+    All addresses will be rounded down to page alignment.\n"</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define CMD_DUMP_HELP_STR       "\</span>
<span class="token inserted">+-SYNOPSIS:\n\</span>
<span class="token inserted">+    dump addr_type addr [size==1]\n\</span>
<span class="token inserted">+-DESCRIPTION:\n\</span>
<span class="token inserted">+    addr_type: '-v' for virtual address, '-p for physical address\n\</span>
<span class="token inserted">+    addr: beginning address\n\</span>
<span class="token inserted">+    size: memory size in dwords(4 bytes)\n"</span>
 
 #endif	// !JOS_KERN_MONITOR_H
diff --git a/kern/pmap.h b/kern/pmap.h
index 950cca1..9d447fc 100644
<span class="token deleted">--- a/kern/pmap.h</span>
<span class="token inserted">+++ b/kern/pmap.h</span>
<span class="token coord">@@ -9,6 +9,12 @@</span>
 #include &lt;inc/memlayout.h>
 #include &lt;inc/assert.h>
 
<span class="token inserted">+#define npages_in_4GB	(1&lt;&lt;(32-PGSHIFT))</span>
<span class="token inserted">+#define DWORD_SIZE		4		// four bytes per dword</span>
<span class="token inserted">+#define DOWRD_SHIFT		2		// log2(DWORD_SIZE)</span>
<span class="token inserted">+#define ndwords_in_4GB	(1&lt;&lt;(32-DOWRD_SHIFT))</span>
<span class="token inserted">+#define DOWRD_NUM(la)	(((uintptr_t) (la)) >> DOWRD_SHIFT)</span>
<span class="token inserted">+</span>
 extern char bootstacktop[], bootstack[];
 
 extern struct PageInfo *pages;
</pre><h3 class="mume-header" id="challenge-3" ebook-toc-level-3="" heading="Challenge 3">Challenge 3</h3>

<blockquote>
<p>Q : Write up an outline of how a kernel could be designed to allow user environments unrestricted use of the full 4GB virtual and linear address space. Hint: the technique is sometimes known as “follow the bouncing kernel.” In your design, be sure to address exactly what has to happen when the processor transitions between kernel and user modes, and how the kernel would accomplish such transitions. Also describe how the kernel would access physical memory and I/O devices in this scheme, and how the kernel would access a user environment’s virtual address space during system calls and the like. Finally, think about and describe the advantages and disadvantages of such a scheme in terms of flexibility, performance, kernel complexity, and other factors you can think of.</p>
</blockquote>
<p>I don’t want to write an essay on this topic. We are surely able to allow user environments unrestricted use of the full 4GB virtual and linear address space. One way to fulfill this requirement is to change user program’s page tables to kernel’s every time it wants to interact with kernel, whose performance is lower than JOS’s choice that a part of memory in user enviroments is reserved for kernel so that we don’t need to change page tables every time the user program want to interact with kernel. Another way is to re-map kernel to another place every time user programs want to use memory occupied by kernel. This technique is called “bouncing kernel”.</p>
<h3 class="mume-header" id="challenge-4" ebook-toc-level-3="" heading="Challenge 4">Challenge 4</h3>

<blockquote>
<p>Q : Since our JOS kernel’s memory management system only allocates and frees memory on page granularity, we do not have anything comparable to a general-purpose malloc/free facility that we can use within the kernel. This could be a problem if we want to support certain types of I/O devices that require physically contiguous buffers larger than 4KB in size, or if we want user-level environments, and not just the kernel, to be able to allocate and map 4MB superpages for maximum processor efficiency. (See the earlier challenge problem about PTE_PS.)<br>
Generalize the kernel’s memory allocation system to support pages of a variety of power-of-two allocation unit sizes from 4KB up to some reasonable maximum of your choice. Be sure you have some way to divide larger allocation units into smaller ones on demand, and to coalesce multiple small allocation units back into larger units when possible. Think about the issues that might arise in such a system.</p>
</blockquote>
<p><strong><a href="https://en.wikipedia.org/wiki/Buddy_system">Buddy System</a></strong> is exactly the answer. In this challenge I implemented a buddy system and initialized the buddy system after all tests in <code>mem_init()</code> so that none of those test would fail. In addition, I wrote my own tests for my buddy system.</p>
<p>The result is shown below.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">***
*** Use Ctrl-a x to <span class="token keyword">exit</span> qemu
***
qemu-system-i386 -nographic -drive file<span class="token operator">=</span>obj/kern/kernel.img,index<span class="token operator">=</span>0,media<span class="token operator">=</span>disk,format<span class="token operator">=</span>raw -serial mon:stdio -gdb tcp::26000 -D qemu.log
6828 decimal is 15254 octal<span class="token operator">!</span>
Physical memory: 131072K available, base <span class="token operator">=</span> 640K, extended <span class="token operator">=</span> 130432K
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_alloc<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_kern_pgdir<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_free_list<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_page_installed_pgdir<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_buddy_tree<span class="token punctuation">(</span><span class="token punctuation">)</span> succeeded<span class="token operator">!</span>
check_buddy_alloc<span class="token operator">&amp;</span>free<span class="token punctuation">(</span><span class="token punctuation">)</span> succeed<span class="token operator">!</span>
Welcome to the JOS kernel monitor<span class="token operator">!</span>
Type <span class="token string">'help'</span> <span class="token keyword">for</span> a list of commands.
K<span class="token operator">></span>
</pre><p>The code for buddy system is shown below.</p>
<pre data-role="codeBlock" data-info="git" class="language-git">diff --git a/inc/memlayout.h b/inc/memlayout.h
index 89bf0e3..7ee983d 100644
<span class="token deleted">--- a/inc/memlayout.h</span>
<span class="token inserted">+++ b/inc/memlayout.h</span>
@@ -174,8 +174,8 @@ extern volatile pde_t uvpd[];     // VA of current page directory
  * with page2pa() in kern/pmap.h.
  */
 struct PageInfo {
<span class="token deleted">-	// Next page on the free list.</span>
<span class="token deleted">-	struct PageInfo *pp_link;</span>
<span class="token inserted">+	struct PageInfo *pp_prev;	// previous page on the free list.</span>
<span class="token inserted">+	struct PageInfo *pp_next;	// next page on the free list</span>
 
 	// pp_ref is the count of pointers (usually in page table entries)
 	// to this page, for pages allocated using page_alloc.
@@ -183,6 +183,11 @@ struct PageInfo {
 	// boot_alloc do not have valid reference count fields.
 
 	uint16_t pp_ref;
<span class="token inserted">+</span>
<span class="token inserted">+	// pp_count == 2^N if this page is N-th order free.</span>
<span class="token inserted">+	// For the declaration of N-th order free, refer to kern/pmap.h</span>
<span class="token inserted">+	// pp_count == 0 means it's not free.</span>
<span class="token inserted">+	uint16_t pp_count;</span>
 };
 
 #endif /* !__ASSEMBLER__ */
diff --git a/kern/pmap.c b/kern/pmap.c
index f22a5e5..384c08b 100644
<span class="token deleted">--- a/kern/pmap.c</span>
<span class="token inserted">+++ b/kern/pmap.c</span>
@@ -19,6 +19,7 @@ pde_t *kern_pgdir;		// Kernel's initial page directory
 struct PageInfo *pages;		// Physical page state array
 static struct PageInfo *page_free_list;	// Free list of physical pages
 
<span class="token inserted">+static struct PageInfo *nOrder_free_pages[MAX_BUDDY_ORDER+1];</span>
 
 // --------------------------------------------------------------
 // Detect machine's physical memory setup.
@@ -69,6 +70,8 @@ static void check_kern_pgdir(void);
 static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
 static void check_page(void);
 static void check_page_installed_pgdir(void);
<span class="token inserted">+static void check_buddy_tree(void);</span>
<span class="token inserted">+static void check_buddy_alloc(void);</span>
 
 // This simple physical memory allocator is used only while JOS is setting
 // up its virtual memory system.  page_alloc() is the real allocator.
@@ -235,6 +238,9 @@ mem_init(void)
 
 	// Some more checks, only possible after kern_pgdir is installed.
 	check_page_installed_pgdir();
<span class="token inserted">+	buddy_tree_init(page_free_list);</span>
<span class="token inserted">+	check_buddy_tree();</span>
<span class="token inserted">+	check_buddy_alloc();</span>
 }
 
 // --------------------------------------------------------------
@@ -311,7 +317,7 @@ page_init(void)
 	 * Figure 2:
 	 * 
 	 *       page N    +--------------------+
<span class="token deleted">-	 *                 |      pp_link       | -----\</span>
<span class="token inserted">+	 *                 |      pp_next       | -----\</span>
 	 *                 +--------------------+      |
 	 *                 |      pp_ref        |      |
 	 *                 +--------------------+      |
@@ -320,7 +326,7 @@ page_init(void)
 	 *                           |
 	 *                           v
 	 *       page N-1  +--------------------+
<span class="token deleted">-	 *                 |      pp_link       | -----\</span>
<span class="token inserted">+	 *                 |      pp_next       | -----\</span>
 	 *                 +--------------------+      |
 	 *                 |      pp_ref        |      |
 	 *                 +--------------------+      |
@@ -333,7 +339,7 @@ page_init(void)
 	 *                           |
 	 *                           v
 	 *       page 1    +--------------------+
<span class="token deleted">-	 *                 |      pp_link       | -----\</span>
<span class="token inserted">+	 *                 |      pp_next       | -----\</span>
 	 *                 +--------------------+      |
 	 *                 |      pp_ref        |      |
 	 *                 +--------------------+      |
@@ -342,7 +348,7 @@ page_init(void)
 	 *                           |
 	 *                           v
 	 *       page 0    +--------------------+
<span class="token deleted">-	 *                 |    pp_link=NULL    |</span>
<span class="token inserted">+	 *                 |    pp_next=NULL    |</span>
 	 *                 +--------------------+
 	 *                 |      pp_ref        |
 	 *                 +--------------------+
@@ -358,7 +364,7 @@ page_init(void)
 		// The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
 		// is free.
 		pages[i].pp_ref = 0;
<span class="token deleted">-		pages[i].pp_link = page_free_list;</span>
<span class="token inserted">+		pages[i].pp_next = page_free_list;</span>
 		page_free_list = &amp;pages[i];
 	}
 
@@ -368,13 +374,13 @@ page_init(void)
 		// in physcial memory. So initialize their corresponding 
 		// page entries in one loop
 		pages[i].pp_ref = 1;
<span class="token deleted">-		pages[i].pp_link = NULL;</span>
<span class="token inserted">+		pages[i].pp_next = NULL;</span>
 	}
 	
 	for (; i &lt; npages; ++i) {
 		// The rest of extended memory are not used
 		pages[i].pp_ref = 0;
<span class="token deleted">-		pages[i].pp_link = page_free_list;</span>
<span class="token inserted">+		pages[i].pp_next = page_free_list;</span>
 		page_free_list = &amp;pages[i];
 	}
 }
@@ -385,7 +391,7 @@ page_init(void)
 // count of the page - the caller must do these if necessary (either explicitly
 // or via page_insert).
 //
<span class="token deleted">-// Be sure to set the pp_link field of the allocated page to NULL so</span>
<span class="token inserted">+// Be sure to set the pp_next field of the allocated page to NULL so</span>
 // page_free can check for double-free bugs.
 //
 // Returns NULL if out of free memory.
@@ -398,8 +404,8 @@ page_alloc(int alloc_flags)
 		return NULL;
 	
 	struct PageInfo *page_allocated = page_free_list;
<span class="token deleted">-	page_free_list = page_free_list->pp_link;</span>
<span class="token deleted">-	page_allocated->pp_link = NULL;</span>
<span class="token inserted">+	page_free_list = page_free_list->pp_next;</span>
<span class="token inserted">+	page_allocated->pp_next = NULL;</span>
 
 	if (alloc_flags &amp; ALLOC_ZERO)
 		memset(page2kva(page_allocated), 0, PGSIZE);
@@ -416,9 +422,9 @@ page_free(struct PageInfo *pp)
 {
 	// Fill this function in
 	// Hint: You may want to panic if pp->pp_ref is nonzero or
<span class="token deleted">-	// pp->pp_link is not NULL.</span>
<span class="token inserted">+	// pp->pp_next is not NULL.</span>
 
<span class="token deleted">-	if (pp->pp_link)		// pp->pp_link is not NULL, double free</span>
<span class="token inserted">+	if (pp->pp_next)		// pp->pp_next is not NULL, double free</span>
 		panic(<span class="token string">"Double free page %u, pvaddr:%x, ppaddr:%x\n"</span>,\
 			(uint32_t)(pp-pages), page2kva(pp), page2pa(pp));
 	
@@ -426,7 +432,7 @@ page_free(struct PageInfo *pp)
 		panic(<span class="token string">"Free a page in use, pnum:%u, pvaddr:%x, ppaddr:%x\n"</span>,\
 			(uint32_t)(pp-pages), page2kva(pp), page2pa(pp));
 	
<span class="token deleted">-	pp->pp_link = page_free_list;</span>
<span class="token inserted">+	pp->pp_next = page_free_list;</span>
 	page_free_list = pp;
 	return;
 }
@@ -641,6 +647,252 @@ tlb_invalidate(pde_t *pgdir, void *va)
 	invlpg(va);
 }
 
<span class="token inserted">+// --------------------------------------------------------------</span>
<span class="token inserted">+// Buddy system functions</span>
<span class="token inserted">+// --------------------------------------------------------------</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * Each doubly linked list is represented by a PageInfo **ptr.</span>
<span class="token inserted">+ * list_push_front(PageInfo **list_ptr, PageInfo *node_ptr) pushes</span>
<span class="token inserted">+ * *node_ptr into the heade the list.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+struct PageInfo *</span>
<span class="token inserted">+list_push_front(struct PageInfo **list_ptr, struct PageInfo *node_ptr)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	struct PageInfo *head_ptr = *list_ptr;</span>
<span class="token inserted">+	node_ptr->pp_next = head_ptr;</span>
<span class="token inserted">+	node_ptr->pp_prev = NULL;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	*list_ptr = node_ptr;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	if (head_ptr == NULL)</span>
<span class="token inserted">+		return node_ptr;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	head_ptr->pp_prev = node_ptr;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	return node_ptr;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * list_pop_front(PageInfo **list_ptr) pops out the head of the linked</span>
<span class="token inserted">+ * list and sets *list_ptr to head_ptr->pp_next. NULL is returned if</span>
<span class="token inserted">+ * list is empty.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+struct PageInfo *</span>
<span class="token inserted">+list_pop_front(struct PageInfo **list_ptr)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	struct PageInfo *head_ptr = *list_ptr;</span>
<span class="token inserted">+	if (head_ptr == NULL)</span>
<span class="token inserted">+		return NULL;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	*list_ptr = head_ptr->pp_next;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	if (*list_ptr)</span>
<span class="token inserted">+		(*list_ptr)->pp_prev = NULL;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	head_ptr->pp_next = NULL;</span>
<span class="token inserted">+	return head_ptr;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * Remove *node_ptr from list_ptr.</span>
<span class="token inserted">+ * This function doesn't check whether node_ptr really belongs</span>
<span class="token inserted">+ * to list_ptr. The caller should guarantee the validation of</span>
<span class="token inserted">+ * arguments. It's the caller's duty to assure node_ptr really</span>
<span class="token inserted">+ * belongs to list_ptr.</span>
<span class="token inserted">+ * </span>
<span class="token inserted">+ * node_ptr->pp_prev and node_ptr->pp_next will be set to NULL.</span>
<span class="token inserted">+ * </span>
<span class="token inserted">+ * if *list_ptr == NULL, node_ptr is return immediately.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+struct PageInfo *</span>
<span class="token inserted">+list_remove(struct PageInfo **list_ptr, struct PageInfo *node_ptr)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	// if list is an empty list</span>
<span class="token inserted">+	if (*list_ptr == NULL)</span>
<span class="token inserted">+		return node_ptr;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// if node_ptr is the first of the linked list, just pop it</span>
<span class="token inserted">+	if (*list_ptr == node_ptr)</span>
<span class="token inserted">+		return list_pop_front(list_ptr);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// Last condition check assures node_ptr is not the first node</span>
<span class="token inserted">+	// in the linked list. So it's safe to use node_ptr->pp_prev.</span>
<span class="token inserted">+	if (node_ptr->pp_prev)</span>
<span class="token inserted">+		node_ptr->pp_prev->pp_next = node_ptr->pp_next;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// if node_ptr is not the last node in the linked list.</span>
<span class="token inserted">+	if (node_ptr->pp_next)</span>
<span class="token inserted">+		node_ptr->pp_next->pp_prev = node_ptr->pp_prev;</span>
<span class="token inserted">+</span>
<span class="token inserted">+</span>
<span class="token inserted">+		</span>
<span class="token inserted">+	node_ptr->pp_prev = NULL;</span>
<span class="token inserted">+	node_ptr->pp_next = NULL;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	return node_ptr;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * return the length of a linked list. An end of a linked list is</span>
<span class="token inserted">+ * represented by NULL. The caller should guarantee the security of</span>
<span class="token inserted">+ * the arugments.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+size_t</span>
<span class="token inserted">+list_length(struct PageInfo **list_ptr)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	size_t count = 0;</span>
<span class="token inserted">+	for (struct PageInfo *node_ptr = *list_ptr; node_ptr; node_ptr = node_ptr->pp_next)</span>
<span class="token inserted">+		++count;</span>
<span class="token inserted">+	return count;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * get n order buddy</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+struct PageInfo *</span>
<span class="token inserted">+get_buddy(struct PageInfo *pp, int order)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	// assure order provided resides in appropriate range</span>
<span class="token inserted">+	assert(order &lt;= MAX_BUDDY_ORDER);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	size_t buddy_bit = (1 &lt;&lt; order);</span>
<span class="token inserted">+	size_t index = page2index(pp);</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// assure the caller demand a test on pp with appropriate order</span>
<span class="token inserted">+	assert((index &amp;(buddy_bit - 1)) == 0);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	size_t buddy_index = index ^ buddy_bit;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// The tree constructed by the buddy system may even not be a </span>
<span class="token inserted">+	// complete binary tree because our memory is not always 2^N</span>
<span class="token inserted">+	// bytes big. It‘s necessary to assure the physical memory</span>
<span class="token inserted">+	// represented by the buddy really exists.</span>
<span class="token inserted">+	return (buddy_index &lt; npages) ? (pages + buddy_index) : NULL;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * check whether a buddy page area is N-th order free</span>
<span class="token inserted">+ * NUll is returned if not.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+struct PageInfo *</span>
<span class="token inserted">+buddy_is_free(struct PageInfo *pp, int order)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	struct PageInfo *buddy = get_buddy(pp, order);</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	return (buddy != NULL &amp;&amp; buddy->pp_count == (1 &lt;&lt; order)) ? buddy : NULL;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * initialize nOrder_free_pages</span>
<span class="token inserted">+ * free page is always inserted to the header of a linked list</span>
<span class="token inserted">+ * pp_free should be the linked list provided by page_init()</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+void buddy_tree_init(struct PageInfo *pp_free)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	struct PageInfo *tmp_ptr;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// nOrder_free_pages == &amp;nOrder_free_pages[0]</span>
<span class="token inserted">+	while (pp_free) {</span>
<span class="token inserted">+		pp_free->pp_count = 1;</span>
<span class="token inserted">+		tmp_ptr = pp_free->pp_next;</span>
<span class="token inserted">+		*nOrder_free_pages = list_push_front(nOrder_free_pages, pp_free);</span>
<span class="token inserted">+		pp_free = tmp_ptr;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	for (int order = 0; nOrder_free_pages[order] &amp;&amp; order &lt; MAX_BUDDY_ORDER; ++order) {</span>
<span class="token inserted">+		int next_order = order + 1;</span>
<span class="token inserted">+		struct PageInfo *buddy_pp;</span>
<span class="token inserted">+		pp_free = nOrder_free_pages[order];</span>
<span class="token inserted">+</span>
<span class="token inserted">+		while (pp_free) {</span>
<span class="token inserted">+			if ((buddy_pp = buddy_is_free(pp_free, order)) != NULL) {</span>
<span class="token inserted">+				// remove [pp_free, buddy_pp] from nOrder_free_pages[this order]</span>
<span class="token inserted">+				list_remove(&amp;nOrder_free_pages[order], pp_free);</span>
<span class="token inserted">+				list_remove(&amp;nOrder_free_pages[order], buddy_pp);</span>
<span class="token inserted">+</span>
<span class="token inserted">+				// sort [pp_free, buddy_pp]</span>
<span class="token inserted">+				struct PageInfo *lower_addr = MIN(buddy_pp, pp_free);</span>
<span class="token inserted">+				</span>
<span class="token inserted">+				// increment the order of free size</span>
<span class="token inserted">+				lower_addr->pp_count = ((lower_addr->pp_count) &lt;&lt; 1);</span>
<span class="token inserted">+</span>
<span class="token inserted">+				// insert the new block into the linked list of next order</span>
<span class="token inserted">+				list_push_front(&amp;nOrder_free_pages[order+1], lower_addr);</span>
<span class="token inserted">+</span>
<span class="token inserted">+				pp_free = nOrder_free_pages[order];</span>
<span class="token inserted">+			} else</span>
<span class="token inserted">+				pp_free = pp_free->pp_next;</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * allocate order free page</span>
<span class="token inserted">+ * return NULL if allocation failed</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+struct PageInfo *</span>
<span class="token inserted">+buddy_alloc_page(int alloc_flags, int order)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	struct PageInfo **best_fit_list = &amp;nOrder_free_pages[order];</span>
<span class="token inserted">+	int best_fit_order = order;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// find best fit list</span>
<span class="token inserted">+	while (*best_fit_list == NULL &amp;&amp; best_fit_order &lt;= MAX_BUDDY_ORDER) {</span>
<span class="token inserted">+		++best_fit_order;</span>
<span class="token inserted">+		++best_fit_list;</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// no contiguous memory big enough is available</span>
<span class="token inserted">+	if (best_fit_order > MAX_BUDDY_ORDER)</span>
<span class="token inserted">+		return NULL;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	// break best fit memory block into 2^order big</span>
<span class="token inserted">+	struct PageInfo *big_block = list_pop_front(best_fit_list);</span>
<span class="token inserted">+	for (; best_fit_order > order; --best_fit_order) {</span>
<span class="token inserted">+		struct PageInfo *lower_order_buddy = &amp;pages[(big_block - pages) ^ (1 &lt;&lt; (best_fit_order - 1))];</span>
<span class="token inserted">+		lower_order_buddy->pp_count = (1 &lt;&lt; (best_fit_order - 1));</span>
<span class="token inserted">+		list_push_front(--best_fit_list, lower_order_buddy);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	big_block->pp_count = (1 &lt;&lt; order);</span>
<span class="token inserted">+	if (alloc_flags &amp; ALLOC_ZERO)</span>
<span class="token inserted">+		memset(page2kva(big_block), 0, (big_block->pp_count) * PGSIZE);</span>
<span class="token inserted">+</span>
<span class="token inserted">+	return big_block;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * free page back to buddy tree</span>
<span class="token inserted">+ * it's the caller's responsibility to assure</span>
<span class="token inserted">+ * pp != NULL, order &lt;= MAX_BUDDY_ORDER and the</span>
<span class="token inserted">+ * contiguous memory to be freed beginning from</span>
<span class="token inserted">+ * pp is truly 2^order big.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+void</span>
<span class="token inserted">+buddy_free_page(struct PageInfo *pp, int order)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	//cprintf("pp num: %d    order: %d\n", pp-pages, order);</span>
<span class="token inserted">+	while (order &lt; MAX_BUDDY_ORDER) {</span>
<span class="token inserted">+		struct PageInfo *buddy = buddy_is_free(pp, order);</span>
<span class="token inserted">+		//cprintf("buddy == NULL: %d\n", buddy == NULL);</span>
<span class="token inserted">+		//cprintf("order %d list length: %d\n", order, list_length(&amp;nOrder_free_pages[order]));</span>
<span class="token inserted">+		if (buddy == NULL)</span>
<span class="token inserted">+			break;</span>
<span class="token inserted">+		list_remove(&amp;nOrder_free_pages[order], buddy);</span>
<span class="token inserted">+		pp = MIN(pp, buddy);</span>
<span class="token inserted">+		++order;</span>
<span class="token inserted">+		pp->pp_count = (1&lt;&lt;order);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// avoid double free</span>
<span class="token inserted">+	struct PageInfo *tmp_buddy = get_buddy(pp, order);</span>
<span class="token inserted">+	if (tmp_buddy != NULL &amp;&amp; tmp_buddy->pp_count > pp->pp_count)</span>
<span class="token inserted">+		return;</span>
<span class="token inserted">+	</span>
<span class="token inserted">+	list_push_front(&amp;nOrder_free_pages[order], pp);</span>
<span class="token inserted">+}</span>
 
 // --------------------------------------------------------------
 // Checking functions.
@@ -665,10 +917,10 @@ check_page_free_list(bool only_low_memory)
 		// list, since entry_pgdir does not map all pages.
 		struct PageInfo *pp1, *pp2;
 		struct PageInfo **tp[2] = { &amp;pp1, &amp;pp2 };
<span class="token deleted">-		for (pp = page_free_list; pp; pp = pp->pp_link) {</span>
<span class="token inserted">+		for (pp = page_free_list; pp; pp = pp->pp_next) {</span>
 			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
 			*tp[pagetype] = pp;
<span class="token deleted">-			tp[pagetype] = &amp;pp->pp_link;</span>
<span class="token inserted">+			tp[pagetype] = &amp;pp->pp_next;</span>
 		}
 		*tp[1] = 0;
 		*tp[0] = pp2;
@@ -677,12 +929,12 @@ check_page_free_list(bool only_low_memory)
 
 	// if there<span class="token string">'s a page that shouldn'</span>t be on the free list,
 	// try to make sure it eventually causes trouble.
<span class="token deleted">-	for (pp = page_free_list; pp; pp = pp->pp_link)</span>
<span class="token inserted">+	for (pp = page_free_list; pp; pp = pp->pp_next)</span>
 		if (PDX(page2pa(pp)) &lt; pdx_limit)
 			memset(page2kva(pp), 0x97, 128);
 
 	first_free_page = (char *) boot_alloc(0);
<span class="token deleted">-	for (pp = page_free_list; pp; pp = pp->pp_link) {</span>
<span class="token inserted">+	for (pp = page_free_list; pp; pp = pp->pp_next) {</span>
 		// check that we didn't corrupt the free list itself
 		assert(pp >= pages);
 		assert(pp &lt; pages + npages);
@@ -707,6 +959,7 @@ check_page_free_list(bool only_low_memory)
 	cprintf(<span class="token string">"check_page_free_list() succeeded!\n"</span>);
 }
 
<span class="token inserted">+</span>
 //
 // Check the physical page allocator (page_alloc(), page_free(),
 // and page_init()).
@@ -724,7 +977,7 @@ check_page_alloc(void)
 		panic(<span class="token string">"'pages' is a null pointer!"</span>);
 
 	// check number of free pages
<span class="token deleted">-	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)</span>
<span class="token inserted">+	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_next)</span>
 		++nfree;
 
 	// should be able to allocate three pages
@@ -778,7 +1031,7 @@ check_page_alloc(void)
 	page_free(pp2);
 
 	// number of free pages should be the same
<span class="token deleted">-	for (pp = page_free_list; pp; pp = pp->pp_link)</span>
<span class="token inserted">+	for (pp = page_free_list; pp; pp = pp->pp_next)</span>
 		--nfree;
 	assert(nfree == 0);
 
@@ -958,7 +1211,7 @@ check_page(void)
 	// test re-inserting pp1 at PGSIZE
 	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
 	assert(pp1->pp_ref);
<span class="token deleted">-	assert(pp1->pp_link == NULL);</span>
<span class="token inserted">+	assert(pp1->pp_next == NULL);</span>
 
 	// unmapping pp1 at PGSIZE should free it
 	page_remove(kern_pgdir, (void*) PGSIZE);
@@ -1050,3 +1303,113 @@ check_page_installed_pgdir(void)
 
 	cprintf(<span class="token string">"check_page_installed_pgdir() succeeded!\n"</span>);
 }
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * check whether the buddy tree is established correctly.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+static void</span>
<span class="token inserted">+check_buddy_tree(void)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+</span>
<span class="token inserted">+	size_t free_count = 0;	// number of free pages</span>
<span class="token inserted">+	size_t used_count = 0;	// number of used pages</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// assure values of elements of PageInfo is consistent</span>
<span class="token inserted">+	// with each other and their own criteria.</span>
<span class="token inserted">+	for (size_t i = 0; i &lt; npages; ++i) {</span>
<span class="token inserted">+		(pages[i].pp_ref == 0 &amp;&amp; pages[i].pp_count > 0) ? ++free_count : ++used_count;</span>
<span class="token inserted">+</span>
<span class="token inserted">+		// pages[i].pp_count should be either zero or the power of two.</span>
<span class="token inserted">+		// It should not be larger than 2^MAX_BUDDY_ORDER.</span>
<span class="token inserted">+		// We should keep in mind that pages[i].pp_count is an unsigend integer.</span>
<span class="token inserted">+		assert(((pages[i].pp_count &lt;= (1 &lt;&lt; MAX_BUDDY_ORDER)) &amp;&amp;</span>
<span class="token inserted">+			((pages[i].pp_count &amp; (pages[i].pp_count - 1)) == 0)));</span>
<span class="token inserted">+</span>
<span class="token inserted">+		// pages[i].pp_ref == 0 means page i is free</span>
<span class="token inserted">+		// pages[i].pp_count > 0 means page is 2^pp_count</span>
<span class="token inserted">+		// the boolean value of these two equations should be always the same.</span>
<span class="token inserted">+		assert(((pages[i].pp_ref == 0) == (pages[i].pp_count > 0)));</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// assure free_count and used_count sums up to npages</span>
<span class="token inserted">+	assert((free_count + used_count == npages));</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// count free pages from buddy tree</span>
<span class="token inserted">+	// check each page's buddy page is not free except for those at MAX_BUDDY_ORDER</span>
<span class="token inserted">+	size_t buddy_free_count = 0;</span>
<span class="token inserted">+	for (int order = 0; order &lt;= MAX_BUDDY_ORDER; ++order) {</span>
<span class="token inserted">+		size_t counter = 0;</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		for (struct PageInfo *node_ptr = nOrder_free_pages[order]; node_ptr; node_ptr = node_ptr->pp_next) {</span>
<span class="token inserted">+			++counter;</span>
<span class="token inserted">+			</span>
<span class="token inserted">+			assert((order == MAX_BUDDY_ORDER || (buddy_is_free(node_ptr, order) == NULL)));</span>
<span class="token inserted">+		}</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		buddy_free_count += counter * (1 &lt;&lt; order);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	assert(buddy_free_count == free_count);</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+	#define BYTE_UNIT	(1)</span>
<span class="token inserted">+	#define KB_UNIT		(BYTE_UNIT &lt;&lt; 10)</span>
<span class="token inserted">+	#define MB_UNIT		(KB_UNIT &lt;&lt; 10)</span>
<span class="token inserted">+</span>
<span class="token inserted">+	int free_memory = free_count * PGSIZE;</span>
<span class="token inserted">+	cprintf("free memory: %dMB", free_memory/MB_UNIT);</span>
<span class="token inserted">+	free_memory = free_memory % MB_UNIT;</span>
<span class="token inserted">+	cprintf(" %dKB", free_memory/KB_UNIT);</span>
<span class="token inserted">+	free_memory = free_memory % KB_UNIT;</span>
<span class="token inserted">+	cprintf(" %dB\n", free_memory);</span>
<span class="token inserted">+*/</span>
<span class="token inserted">+</span>
<span class="token inserted">+	cprintf("check_buddy_tree() succeeded!\n");</span>
<span class="token inserted">+}</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * check buddy_alloc, buddy_free</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+static void</span>
<span class="token inserted">+check_buddy_alloc(void)</span>
<span class="token inserted">+{</span>
<span class="token inserted">+	size_t free_page_count = 0;</span>
<span class="token inserted">+	size_t free_count_in_each_order[MAX_BUDDY_ORDER+1];</span>
<span class="token inserted">+	memset(free_count_in_each_order, 0, sizeof(free_count_in_each_order));</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// record free page number</span>
<span class="token inserted">+	for (size_t order = 0; order &lt;= MAX_BUDDY_ORDER; ++order) {</span>
<span class="token inserted">+		size_t counter = list_length(&amp;nOrder_free_pages[order]);</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		free_count_in_each_order[order] = counter;</span>
<span class="token inserted">+		</span>
<span class="token inserted">+		free_page_count += counter * (1 &lt;&lt; order);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+	/*</span>
<span class="token inserted">+	cprintf("free page count: %d\n", free_page_count);</span>
<span class="token inserted">+	for (int i = 0; i &lt;= MAX_BUDDY_ORDER; ++i)</span>
<span class="token inserted">+		cprintf("order: %d    count: %d\n", i, free_count_in_each_order[i]);</span>
<span class="token inserted">+	*/</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// exhaust memory</span>
<span class="token inserted">+	size_t alloc_times = 0;</span>
<span class="token inserted">+	while (buddy_alloc_page(0, 0))</span>
<span class="token inserted">+		++alloc_times;</span>
<span class="token inserted">+</span>
<span class="token inserted">+	assert((alloc_times == free_page_count));</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// free memory allocated before</span>
<span class="token inserted">+	for (size_t i = 0; i &lt; npages; ++i) {</span>
<span class="token inserted">+		if (pages[i].pp_count == 1)</span>
<span class="token inserted">+			buddy_free_page(&amp;pages[i], 0);</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	// check whether buddy tree is restored after freeing pages</span>
<span class="token inserted">+	for (size_t order = 0; order &lt;= MAX_BUDDY_ORDER; ++order) {</span>
<span class="token inserted">+		size_t counter = list_length(&amp;nOrder_free_pages[order]);</span>
<span class="token inserted">+</span>
<span class="token inserted">+		assert((counter == free_count_in_each_order[order]));</span>
<span class="token inserted">+	}</span>
<span class="token inserted">+</span>
<span class="token inserted">+	cprintf("check_buddy_alloc&amp;free() succeed!\n");</span>
<span class="token inserted">+}</span>
\ No newline at end of file
diff --git a/kern/pmap.h b/kern/pmap.h
index 9d447fc..da39b34 100644
<span class="token deleted">--- a/kern/pmap.h</span>
<span class="token inserted">+++ b/kern/pmap.h</span>
@@ -90,4 +90,33 @@ page2kva(struct PageInfo *pp)
 
 pte_t *pgdir_walk(pde_t *pgdir, const void *va, int create);
 
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * Some concept in buddy system</span>
<span class="token inserted">+ * The minimal memory unit is a page(4KB).</span>
<span class="token inserted">+ * 2^order pages is allocated each time.</span>
<span class="token inserted">+ * The N-th order buddy page is the buddy of a page which is the</span>
<span class="token inserted">+ * first page of 2^order contiguous pages. Thus the buddy's order</span>
<span class="token inserted">+ * of a page can not be arbitrarily large. For eaxmple, (110)_2 page</span>
<span class="token inserted">+ * has 2-th order buddy page at most.</span>
<span class="token inserted">+ * Another trick we should point out is that if bit-N(counting from</span>
<span class="token inserted">+ * left and N starts at zero) is the first non-zero bit of index.</span>
<span class="token inserted">+ * Then this page has N-th buddy page at most. And by toggling bit-N,</span>
<span class="token inserted">+ * we get the index of its buddy page.</span>
<span class="token inserted">+ * If a page is the first page of 2^N contiguous pages, we call</span>
<span class="token inserted">+ * the page is N-th order free.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+</span>
<span class="token inserted">+#define MAX_BUDDY_ORDER	10	// the biggest guaranteed memory is 2^10 pages, i.e. 4MB</span>
<span class="token inserted">+</span>
<span class="token inserted">+struct PageInfo * buddy_is_free(struct PageInfo *pp, int order);</span>
<span class="token inserted">+void buddy_tree_init(struct PageInfo *pp_free);</span>
<span class="token inserted">+struct PageInfo *buddy_alloc_page(int alloc_flags, int order);</span>
<span class="token inserted">+void buddy_free_page(struct PageInfo *pp, int order);</span>
<span class="token inserted">+</span>
<span class="token inserted">+/*</span>
<span class="token inserted">+ * This macro takes a PageInfo pointer and returns its index in the pages array.</span>
<span class="token inserted">+ */</span>
<span class="token inserted">+#define page2index(pp)	((pp) - pages)</span>
<span class="token inserted">+</span>
 #endif /* !JOS_KERN_PMAP_H */
</pre><h2 class="mume-header" id="grade" ebook-toc-level-2="" heading="Grade">Grade</h2>

<p>Finally, we got our grade.</p>
<pre data-role="codeBlock" data-info="bash" class="language-bash">running JOS: <span class="token punctuation">(</span>2.2s<span class="token punctuation">)</span>
  Physical page allocator: OK
  Page management: OK
  Kernel page directory: OK
  Page management 2: OK
Score: 70/70
</pre><div class="code-chunk" data-id="code-chunk-id-3" data-cmd="python"><div class="input-div"><div class="btn-group"><div class="run-btn btn"><span>▶︎</span></div><div class="run-all-btn btn">all</div></div><div class="status">running...</div></div><div class="output-div"><footer style="width:100%;text-align:center;font-family:Times">End of Lab 2 Report<br>Email: <a mailto="caoshuyang1996@pku.edu.cn" href="file:///d:\Project\JOS-Lab\reports\lab 2">caoshuyang@pku.edu.cn</a> GitHub: <a href="https://github.com/CaoSY/JOS-Lab" title="JOS Lab">JOS-Lab</a></footer>
</div></div></div>
    </div>
  </body>
</html>            
